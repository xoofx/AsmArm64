// Copyright (c) Alexandre Mutel. All rights reserved.
// Licensed under the BSD-Clause 2 license.
// See license.txt file in the project root for full license information.

// This file is automatically generated. DO NOT EDIT. Changes will be lost if the file is regenerated.

using System.Runtime.CompilerServices;

// ReSharper disable InconsistentNaming
namespace AsmArm64;

/// <summary>
/// Defines the kind of register.
/// </summary>
public enum Arm64RegisterKind : byte
{
    /// <summary>
    /// Invalid register kind.
    /// </summary>
    Invalid = 0,
    /// <summary>
    /// 64-bit general-purpose register.
    /// </summary>
    X,
    /// <summary>
    /// 32-bit general-purpose register.
    /// </summary>
    W,
    /// <summary>
    /// Control Register.
    /// </summary>
    C,
    /// <summary>
    /// 32-bit Stack pointer register.
    /// </summary>
    SP,
    /// <summary>
    /// 32-bit Stack pointer register.
    /// </summary>
    WSP,
    /// <summary>
    /// Vector register.
    /// </summary>
    V,
    /// <summary>
    /// Vector Typed register (Vn.8B, Vn.16B, Vn.4H, Vn.8H, Vn.2S, Vn.4S, Vn.2D).
    /// </summary>
    VPacked,
    /// <summary>
    /// Vector Indexed register (Vn.2B[0], Vn.4B[1], Vn.2H[2]).
    /// </summary>
    VPackedIndexed,
    /// <summary>
    /// Vector Typed register (Vn.B, Vn.H, Vn.S, Vn.D).
    /// </summary>
    VTyped,
    /// <summary>
    /// Vector Indexed register (Vn.B[0], Vn.H[1], Vn.S[2], Vn.D[0]).
    /// </summary>
    VTypedIndexed,
    /// <summary>
    /// Vector Scalar element (e.g. H0 / S0 / D0).
    /// </summary>
    VScalar,
}

/// <summary>
/// Defines the kind of vector typed register (e.g. Vn.8B).
/// </summary>
public enum Arm64RegisterVKind : byte
{
    /// <summary>
    /// The default vector register (or none for a non vector register).
    /// </summary>
    Default = 0,
    /// <summary>
    /// 8-bit vector register.
    /// </summary>
    B,
    /// <summary>
    /// Half-precision 16-bit floating-point register.
    /// </summary>
    H,
    /// <summary>
    /// Single-precision 32-bit floating-point register.
    /// </summary>
    S,
    /// <summary>
    /// Double-precision 64-bit floating-point register.
    /// </summary>
    D,
    /// <summary>
    /// Double-precision 64-bit floating-point register.
    /// </summary>
    Q,
}

/// <summary>
/// Represents an ARM64 X 64-bit general-purpose register.
/// </summary>
public readonly record struct Arm64RegisterX : IArm64Register
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterX(int index) => _value = ((uint)Arm64RegisterKind.X << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterX register) => Unsafe.BitCast<Arm64RegisterX, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register register to a X register.
    /// </summary>
    public static explicit operator Arm64RegisterX(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.X || register.VKind != Arm64RegisterVKind.Default)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind} to Arm64RegisterKind.X");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterX>(register);
    }

    /// <summary>
    /// Gets the X0 register.
    /// </summary>
    public static Arm64RegisterX X0 => new(0);

    /// <summary>
    /// Gets the X1 register.
    /// </summary>
    public static Arm64RegisterX X1 => new(1);

    /// <summary>
    /// Gets the X2 register.
    /// </summary>
    public static Arm64RegisterX X2 => new(2);

    /// <summary>
    /// Gets the X3 register.
    /// </summary>
    public static Arm64RegisterX X3 => new(3);

    /// <summary>
    /// Gets the X4 register.
    /// </summary>
    public static Arm64RegisterX X4 => new(4);

    /// <summary>
    /// Gets the X5 register.
    /// </summary>
    public static Arm64RegisterX X5 => new(5);

    /// <summary>
    /// Gets the X6 register.
    /// </summary>
    public static Arm64RegisterX X6 => new(6);

    /// <summary>
    /// Gets the X7 register.
    /// </summary>
    public static Arm64RegisterX X7 => new(7);

    /// <summary>
    /// Gets the X8 register.
    /// </summary>
    public static Arm64RegisterX X8 => new(8);

    /// <summary>
    /// Gets the X9 register.
    /// </summary>
    public static Arm64RegisterX X9 => new(9);

    /// <summary>
    /// Gets the X10 register.
    /// </summary>
    public static Arm64RegisterX X10 => new(10);

    /// <summary>
    /// Gets the X11 register.
    /// </summary>
    public static Arm64RegisterX X11 => new(11);

    /// <summary>
    /// Gets the X12 register.
    /// </summary>
    public static Arm64RegisterX X12 => new(12);

    /// <summary>
    /// Gets the X13 register.
    /// </summary>
    public static Arm64RegisterX X13 => new(13);

    /// <summary>
    /// Gets the X14 register.
    /// </summary>
    public static Arm64RegisterX X14 => new(14);

    /// <summary>
    /// Gets the X15 register.
    /// </summary>
    public static Arm64RegisterX X15 => new(15);

    /// <summary>
    /// Gets the X16 register.
    /// </summary>
    public static Arm64RegisterX X16 => new(16);

    /// <summary>
    /// Gets the X17 register.
    /// </summary>
    public static Arm64RegisterX X17 => new(17);

    /// <summary>
    /// Gets the X18 register.
    /// </summary>
    public static Arm64RegisterX X18 => new(18);

    /// <summary>
    /// Gets the X19 register.
    /// </summary>
    public static Arm64RegisterX X19 => new(19);

    /// <summary>
    /// Gets the X20 register.
    /// </summary>
    public static Arm64RegisterX X20 => new(20);

    /// <summary>
    /// Gets the X21 register.
    /// </summary>
    public static Arm64RegisterX X21 => new(21);

    /// <summary>
    /// Gets the X22 register.
    /// </summary>
    public static Arm64RegisterX X22 => new(22);

    /// <summary>
    /// Gets the X23 register.
    /// </summary>
    public static Arm64RegisterX X23 => new(23);

    /// <summary>
    /// Gets the X24 register.
    /// </summary>
    public static Arm64RegisterX X24 => new(24);

    /// <summary>
    /// Gets the X25 register.
    /// </summary>
    public static Arm64RegisterX X25 => new(25);

    /// <summary>
    /// Gets the X26 register.
    /// </summary>
    public static Arm64RegisterX X26 => new(26);

    /// <summary>
    /// Gets the X27 register.
    /// </summary>
    public static Arm64RegisterX X27 => new(27);

    /// <summary>
    /// Gets the X28 register.
    /// </summary>
    public static Arm64RegisterX X28 => new(28);

    /// <summary>
    /// Gets the X29 register.
    /// </summary>
    public static Arm64RegisterX X29 => new(29);

    /// <summary>
    /// Gets the X30 register.
    /// </summary>
    public static Arm64RegisterX X30 => new(30);

    /// <summary>
    /// Gets the XZR register.
    /// </summary>
    public static Arm64RegisterX XZR => new(31);
}

/// <summary>
/// Represents an ARM64 W 32-bit general-purpose register.
/// </summary>
public readonly record struct Arm64RegisterW : IArm64Register
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterW(int index) => _value = ((uint)Arm64RegisterKind.W << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterW register) => Unsafe.BitCast<Arm64RegisterW, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register register to a W register.
    /// </summary>
    public static explicit operator Arm64RegisterW(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.W || register.VKind != Arm64RegisterVKind.Default)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind} to Arm64RegisterKind.W");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterW>(register);
    }

    /// <summary>
    /// Gets the W0 register.
    /// </summary>
    public static Arm64RegisterW W0 => new(0);

    /// <summary>
    /// Gets the W1 register.
    /// </summary>
    public static Arm64RegisterW W1 => new(1);

    /// <summary>
    /// Gets the W2 register.
    /// </summary>
    public static Arm64RegisterW W2 => new(2);

    /// <summary>
    /// Gets the W3 register.
    /// </summary>
    public static Arm64RegisterW W3 => new(3);

    /// <summary>
    /// Gets the W4 register.
    /// </summary>
    public static Arm64RegisterW W4 => new(4);

    /// <summary>
    /// Gets the W5 register.
    /// </summary>
    public static Arm64RegisterW W5 => new(5);

    /// <summary>
    /// Gets the W6 register.
    /// </summary>
    public static Arm64RegisterW W6 => new(6);

    /// <summary>
    /// Gets the W7 register.
    /// </summary>
    public static Arm64RegisterW W7 => new(7);

    /// <summary>
    /// Gets the W8 register.
    /// </summary>
    public static Arm64RegisterW W8 => new(8);

    /// <summary>
    /// Gets the W9 register.
    /// </summary>
    public static Arm64RegisterW W9 => new(9);

    /// <summary>
    /// Gets the W10 register.
    /// </summary>
    public static Arm64RegisterW W10 => new(10);

    /// <summary>
    /// Gets the W11 register.
    /// </summary>
    public static Arm64RegisterW W11 => new(11);

    /// <summary>
    /// Gets the W12 register.
    /// </summary>
    public static Arm64RegisterW W12 => new(12);

    /// <summary>
    /// Gets the W13 register.
    /// </summary>
    public static Arm64RegisterW W13 => new(13);

    /// <summary>
    /// Gets the W14 register.
    /// </summary>
    public static Arm64RegisterW W14 => new(14);

    /// <summary>
    /// Gets the W15 register.
    /// </summary>
    public static Arm64RegisterW W15 => new(15);

    /// <summary>
    /// Gets the W16 register.
    /// </summary>
    public static Arm64RegisterW W16 => new(16);

    /// <summary>
    /// Gets the W17 register.
    /// </summary>
    public static Arm64RegisterW W17 => new(17);

    /// <summary>
    /// Gets the W18 register.
    /// </summary>
    public static Arm64RegisterW W18 => new(18);

    /// <summary>
    /// Gets the W19 register.
    /// </summary>
    public static Arm64RegisterW W19 => new(19);

    /// <summary>
    /// Gets the W20 register.
    /// </summary>
    public static Arm64RegisterW W20 => new(20);

    /// <summary>
    /// Gets the W21 register.
    /// </summary>
    public static Arm64RegisterW W21 => new(21);

    /// <summary>
    /// Gets the W22 register.
    /// </summary>
    public static Arm64RegisterW W22 => new(22);

    /// <summary>
    /// Gets the W23 register.
    /// </summary>
    public static Arm64RegisterW W23 => new(23);

    /// <summary>
    /// Gets the W24 register.
    /// </summary>
    public static Arm64RegisterW W24 => new(24);

    /// <summary>
    /// Gets the W25 register.
    /// </summary>
    public static Arm64RegisterW W25 => new(25);

    /// <summary>
    /// Gets the W26 register.
    /// </summary>
    public static Arm64RegisterW W26 => new(26);

    /// <summary>
    /// Gets the W27 register.
    /// </summary>
    public static Arm64RegisterW W27 => new(27);

    /// <summary>
    /// Gets the W28 register.
    /// </summary>
    public static Arm64RegisterW W28 => new(28);

    /// <summary>
    /// Gets the W29 register.
    /// </summary>
    public static Arm64RegisterW W29 => new(29);

    /// <summary>
    /// Gets the W30 register.
    /// </summary>
    public static Arm64RegisterW W30 => new(30);

    /// <summary>
    /// Gets the WZR register.
    /// </summary>
    public static Arm64RegisterW WZR => new(31);
}

/// <summary>
/// Represents an ARM64 C Control Register.
/// </summary>
public readonly record struct Arm64RegisterC : IArm64Register
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterC(int index) => _value = ((uint)Arm64RegisterKind.C << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterC register) => Unsafe.BitCast<Arm64RegisterC, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register register to a C register.
    /// </summary>
    public static explicit operator Arm64RegisterC(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.C || register.VKind != Arm64RegisterVKind.Default)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind} to Arm64RegisterKind.C");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterC>(register);
    }

    /// <summary>
    /// Gets the C0 register.
    /// </summary>
    public static Arm64RegisterC C0 => new(0);

    /// <summary>
    /// Gets the C1 register.
    /// </summary>
    public static Arm64RegisterC C1 => new(1);

    /// <summary>
    /// Gets the C2 register.
    /// </summary>
    public static Arm64RegisterC C2 => new(2);

    /// <summary>
    /// Gets the C3 register.
    /// </summary>
    public static Arm64RegisterC C3 => new(3);

    /// <summary>
    /// Gets the C4 register.
    /// </summary>
    public static Arm64RegisterC C4 => new(4);

    /// <summary>
    /// Gets the C5 register.
    /// </summary>
    public static Arm64RegisterC C5 => new(5);

    /// <summary>
    /// Gets the C6 register.
    /// </summary>
    public static Arm64RegisterC C6 => new(6);

    /// <summary>
    /// Gets the C7 register.
    /// </summary>
    public static Arm64RegisterC C7 => new(7);

    /// <summary>
    /// Gets the C8 register.
    /// </summary>
    public static Arm64RegisterC C8 => new(8);

    /// <summary>
    /// Gets the C9 register.
    /// </summary>
    public static Arm64RegisterC C9 => new(9);

    /// <summary>
    /// Gets the C10 register.
    /// </summary>
    public static Arm64RegisterC C10 => new(10);

    /// <summary>
    /// Gets the C11 register.
    /// </summary>
    public static Arm64RegisterC C11 => new(11);

    /// <summary>
    /// Gets the C12 register.
    /// </summary>
    public static Arm64RegisterC C12 => new(12);

    /// <summary>
    /// Gets the C13 register.
    /// </summary>
    public static Arm64RegisterC C13 => new(13);

    /// <summary>
    /// Gets the C14 register.
    /// </summary>
    public static Arm64RegisterC C14 => new(14);

    /// <summary>
    /// Gets the C15 register.
    /// </summary>
    public static Arm64RegisterC C15 => new(15);
}

/// <summary>
/// Represents an ARM64 SP 32-bit Stack pointer register.
/// </summary>
public readonly record struct Arm64RegisterSP : IArm64Register
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterSP(int index) => _value = ((uint)Arm64RegisterKind.SP << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterSP register) => Unsafe.BitCast<Arm64RegisterSP, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register register to a SP register.
    /// </summary>
    public static explicit operator Arm64RegisterSP(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.SP || register.VKind != Arm64RegisterVKind.Default)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind} to Arm64RegisterKind.SP");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterSP>(register);
    }

    /// <summary>
    /// Gets the SP register.
    /// </summary>
    public static Arm64RegisterSP SP => new(31);
}

/// <summary>
/// Represents an ARM64 WSP 32-bit Stack pointer register.
/// </summary>
public readonly record struct Arm64RegisterWSP : IArm64Register
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterWSP(int index) => _value = ((uint)Arm64RegisterKind.WSP << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterWSP register) => Unsafe.BitCast<Arm64RegisterWSP, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register register to a WSP register.
    /// </summary>
    public static explicit operator Arm64RegisterWSP(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.WSP || register.VKind != Arm64RegisterVKind.Default)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind} to Arm64RegisterKind.WSP");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterWSP>(register);
    }

    /// <summary>
    /// Gets the WSP register.
    /// </summary>
    public static Arm64RegisterWSP WSP => new(31);
}

/// <summary>
/// Represents an ARM64 V Vector register.
/// </summary>
public readonly record struct Arm64RegisterV : IArm64RegisterV
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV(int index) => _value = ((uint)Arm64RegisterKind.V << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => Arm64RegisterVKind.Default;

    /// <summary>
    /// Gets the V.B register.
    /// </summary>
    public Arm64RegisterV_B B => new(Index);

    /// <summary>
    /// Gets the 2 x B V register.
    /// </summary>
    public Arm64RegisterV_2B T_2B => new(Index);

    /// <summary>
    /// Gets the 4 x B V register.
    /// </summary>
    public Arm64RegisterV_4B T_4B => new(Index);

    /// <summary>
    /// Gets the 8 x B V register.
    /// </summary>
    public Arm64RegisterV_8B T_8B => new(Index);

    /// <summary>
    /// Gets the 16 x B V register.
    /// </summary>
    public Arm64RegisterV_16B T_16B => new(Index);

    /// <summary>
    /// Gets the V.H register.
    /// </summary>
    public Arm64RegisterV_H H => new(Index);

    /// <summary>
    /// Gets the 2 x H V register.
    /// </summary>
    public Arm64RegisterV_2H T_2H => new(Index);

    /// <summary>
    /// Gets the 4 x H V register.
    /// </summary>
    public Arm64RegisterV_4H T_4H => new(Index);

    /// <summary>
    /// Gets the 8 x H V register.
    /// </summary>
    public Arm64RegisterV_8H T_8H => new(Index);

    /// <summary>
    /// Gets the V.S register.
    /// </summary>
    public Arm64RegisterV_S S => new(Index);

    /// <summary>
    /// Gets the 2 x S V register.
    /// </summary>
    public Arm64RegisterV_2S T_2S => new(Index);

    /// <summary>
    /// Gets the 4 x S V register.
    /// </summary>
    public Arm64RegisterV_4S T_4S => new(Index);

    /// <summary>
    /// Gets the V.D register.
    /// </summary>
    public Arm64RegisterV_D D => new(Index);

    /// <summary>
    /// Gets the 1 x D V register.
    /// </summary>
    public Arm64RegisterV_1D T_1D => new(Index);

    /// <summary>
    /// Gets the 2 x D V register.
    /// </summary>
    public Arm64RegisterV_2D T_2D => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV register) => Unsafe.BitCast<Arm64RegisterV, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register register to a V register.
    /// </summary>
    public static explicit operator Arm64RegisterV(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.V || register.VKind != Arm64RegisterVKind.Default)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind} to Arm64RegisterKind.V");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV>(register);
    }

    /// <summary>
    /// Gets the V0 register.
    /// </summary>
    public static Arm64RegisterV V0 => new(0);

    /// <summary>
    /// Gets the V1 register.
    /// </summary>
    public static Arm64RegisterV V1 => new(1);

    /// <summary>
    /// Gets the V2 register.
    /// </summary>
    public static Arm64RegisterV V2 => new(2);

    /// <summary>
    /// Gets the V3 register.
    /// </summary>
    public static Arm64RegisterV V3 => new(3);

    /// <summary>
    /// Gets the V4 register.
    /// </summary>
    public static Arm64RegisterV V4 => new(4);

    /// <summary>
    /// Gets the V5 register.
    /// </summary>
    public static Arm64RegisterV V5 => new(5);

    /// <summary>
    /// Gets the V6 register.
    /// </summary>
    public static Arm64RegisterV V6 => new(6);

    /// <summary>
    /// Gets the V7 register.
    /// </summary>
    public static Arm64RegisterV V7 => new(7);

    /// <summary>
    /// Gets the V8 register.
    /// </summary>
    public static Arm64RegisterV V8 => new(8);

    /// <summary>
    /// Gets the V9 register.
    /// </summary>
    public static Arm64RegisterV V9 => new(9);

    /// <summary>
    /// Gets the V10 register.
    /// </summary>
    public static Arm64RegisterV V10 => new(10);

    /// <summary>
    /// Gets the V11 register.
    /// </summary>
    public static Arm64RegisterV V11 => new(11);

    /// <summary>
    /// Gets the V12 register.
    /// </summary>
    public static Arm64RegisterV V12 => new(12);

    /// <summary>
    /// Gets the V13 register.
    /// </summary>
    public static Arm64RegisterV V13 => new(13);

    /// <summary>
    /// Gets the V14 register.
    /// </summary>
    public static Arm64RegisterV V14 => new(14);

    /// <summary>
    /// Gets the V15 register.
    /// </summary>
    public static Arm64RegisterV V15 => new(15);

    /// <summary>
    /// Gets the V16 register.
    /// </summary>
    public static Arm64RegisterV V16 => new(16);

    /// <summary>
    /// Gets the V17 register.
    /// </summary>
    public static Arm64RegisterV V17 => new(17);

    /// <summary>
    /// Gets the V18 register.
    /// </summary>
    public static Arm64RegisterV V18 => new(18);

    /// <summary>
    /// Gets the V19 register.
    /// </summary>
    public static Arm64RegisterV V19 => new(19);

    /// <summary>
    /// Gets the V20 register.
    /// </summary>
    public static Arm64RegisterV V20 => new(20);

    /// <summary>
    /// Gets the V21 register.
    /// </summary>
    public static Arm64RegisterV V21 => new(21);

    /// <summary>
    /// Gets the V22 register.
    /// </summary>
    public static Arm64RegisterV V22 => new(22);

    /// <summary>
    /// Gets the V23 register.
    /// </summary>
    public static Arm64RegisterV V23 => new(23);

    /// <summary>
    /// Gets the V24 register.
    /// </summary>
    public static Arm64RegisterV V24 => new(24);

    /// <summary>
    /// Gets the V25 register.
    /// </summary>
    public static Arm64RegisterV V25 => new(25);

    /// <summary>
    /// Gets the V26 register.
    /// </summary>
    public static Arm64RegisterV V26 => new(26);

    /// <summary>
    /// Gets the V27 register.
    /// </summary>
    public static Arm64RegisterV V27 => new(27);

    /// <summary>
    /// Gets the V28 register.
    /// </summary>
    public static Arm64RegisterV V28 => new(28);

    /// <summary>
    /// Gets the V29 register.
    /// </summary>
    public static Arm64RegisterV V29 => new(29);

    /// <summary>
    /// Gets the V30 register.
    /// </summary>
    public static Arm64RegisterV V30 => new(30);

    /// <summary>
    /// Gets the V31 register.
    /// </summary>
    public static Arm64RegisterV V31 => new(31);
}
/// <summary>
/// Represents an ARM64 a vector typed with 8-bit vector register (V.B arrangement).
/// </summary>
public readonly record struct Arm64RegisterV_B : IArm64RegisterVTyped
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_B(int index) => _value = ((uint)Arm64RegisterVKind.B << 16) | ((uint)Arm64RegisterKind.VTyped << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <summary>
    /// Gets the indexed element of this vector typed register.
    /// </summary>
    public Indexed this[int elementIndex] => new(Index, elementIndex);

    /// <summary>
    /// Gets the base register of this vector typed register.
    /// </summary>
    public Arm64RegisterV BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_B register) => Unsafe.BitCast<Arm64RegisterV_B, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.B register.
    /// </summary>
    public static explicit operator Arm64RegisterV_B(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VTyped || register.VKind != Arm64RegisterVKind.B)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_B");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_B>(register);
    }

    /// <summary>
    /// Represents an ARM64 a vector indexed with 8-bit vector register (V.B arrangement).
    /// </summary>
    public readonly record struct Indexed : IArm64RegisterVTyped, IArm64RegisterVIndexed
    {
        private readonly uint _value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal Indexed(int registerIndex, int elementIndex) => _value = ((uint)elementIndex << 28) | ((uint)Arm64RegisterVKind.B << 16) | ((uint)Arm64RegisterKind.VTypedIndexed << 8) | (uint)registerIndex;

        /// <inheritdoc />
        public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

        /// <inheritdoc />
        public int Index => (byte)_value;

        /// <inheritdoc />
        public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

        /// <inheritdoc />
        public int ElementIndex => (byte)(_value >> 28);

        /// <summary>
        /// Gets the base register of this indexed vector register.
        /// </summary>
        public Arm64RegisterV_B BaseRegister => new(Index);

        /// <inheritdoc />
        public override string ToString() => ToString(null, null);

        /// <inheritdoc />
        [SkipLocalsInit]
        public string ToString(string? format, IFormatProvider? formatProvider)
        {
            Span<char> localText = stackalloc char[16];
            return !TryFormat(localText, out var charsWritten, format, formatProvider) ? string.Empty : localText.Slice(0, charsWritten).ToString();
        }

        /// <inheritdoc />
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            if (!BaseRegister.TryFormat(destination, out var tempWritten, format, provider))
            {
                charsWritten = 0;
                return false;
            }
            // [1] to [16] (3 to 4 characters)
            if (destination.Length < tempWritten + 4)
            {
                charsWritten = 0;
                return false;
            }
            destination[tempWritten] = '[';
            if (ElementIndex >= 10)
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex / 10);
                destination[tempWritten + 2] = (char)('0' + ElementIndex % 10);
                charsWritten = tempWritten + 3;
            }
            else
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex);
                charsWritten = tempWritten + 2;
            }
            destination[charsWritten] = ']';

            charsWritten++;
            return true;
        }

        /// <summary>
        /// Converts this register to an any register.
        /// </summary>
        public static implicit operator Arm64RegisterAny(Indexed register) => Unsafe.BitCast<Indexed, Arm64RegisterAny>(register);

        /// <summary>
        /// Converts an any register to a V.B register.
        /// </summary>
        public static explicit operator Indexed(Arm64RegisterAny register)
        {
            if (register.Kind != Arm64RegisterKind.VTypedIndexed || register.VKind != Arm64RegisterVKind.B)
            {
                throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_B.Indexed");
            }
            return Unsafe.BitCast<Arm64RegisterAny, Indexed>(register);
        }
    }
}

/// <summary>
/// Represents an ARM64 a 8-bit vector register (B arrangement).
/// </summary>
public readonly record struct Arm64RegisterB : IArm64RegisterVScalar
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterB(int index) => _value = ((uint)Arm64RegisterVKind.B << 16) | ((uint)Arm64RegisterKind.VScalar << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterB register) => Unsafe.BitCast<Arm64RegisterB, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.B register.
    /// </summary>
    public static explicit operator Arm64RegisterB(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VScalar || register.VKind != Arm64RegisterVKind.B)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterB");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterB>(register);
    }

    /// <summary>
    /// Gets the B0 register.
    /// </summary>
    public static Arm64RegisterB B0 => new(0);

    /// <summary>
    /// Gets the B1 register.
    /// </summary>
    public static Arm64RegisterB B1 => new(1);

    /// <summary>
    /// Gets the B2 register.
    /// </summary>
    public static Arm64RegisterB B2 => new(2);

    /// <summary>
    /// Gets the B3 register.
    /// </summary>
    public static Arm64RegisterB B3 => new(3);

    /// <summary>
    /// Gets the B4 register.
    /// </summary>
    public static Arm64RegisterB B4 => new(4);

    /// <summary>
    /// Gets the B5 register.
    /// </summary>
    public static Arm64RegisterB B5 => new(5);

    /// <summary>
    /// Gets the B6 register.
    /// </summary>
    public static Arm64RegisterB B6 => new(6);

    /// <summary>
    /// Gets the B7 register.
    /// </summary>
    public static Arm64RegisterB B7 => new(7);

    /// <summary>
    /// Gets the B8 register.
    /// </summary>
    public static Arm64RegisterB B8 => new(8);

    /// <summary>
    /// Gets the B9 register.
    /// </summary>
    public static Arm64RegisterB B9 => new(9);

    /// <summary>
    /// Gets the B10 register.
    /// </summary>
    public static Arm64RegisterB B10 => new(10);

    /// <summary>
    /// Gets the B11 register.
    /// </summary>
    public static Arm64RegisterB B11 => new(11);

    /// <summary>
    /// Gets the B12 register.
    /// </summary>
    public static Arm64RegisterB B12 => new(12);

    /// <summary>
    /// Gets the B13 register.
    /// </summary>
    public static Arm64RegisterB B13 => new(13);

    /// <summary>
    /// Gets the B14 register.
    /// </summary>
    public static Arm64RegisterB B14 => new(14);

    /// <summary>
    /// Gets the B15 register.
    /// </summary>
    public static Arm64RegisterB B15 => new(15);

    /// <summary>
    /// Gets the B16 register.
    /// </summary>
    public static Arm64RegisterB B16 => new(16);

    /// <summary>
    /// Gets the B17 register.
    /// </summary>
    public static Arm64RegisterB B17 => new(17);

    /// <summary>
    /// Gets the B18 register.
    /// </summary>
    public static Arm64RegisterB B18 => new(18);

    /// <summary>
    /// Gets the B19 register.
    /// </summary>
    public static Arm64RegisterB B19 => new(19);

    /// <summary>
    /// Gets the B20 register.
    /// </summary>
    public static Arm64RegisterB B20 => new(20);

    /// <summary>
    /// Gets the B21 register.
    /// </summary>
    public static Arm64RegisterB B21 => new(21);

    /// <summary>
    /// Gets the B22 register.
    /// </summary>
    public static Arm64RegisterB B22 => new(22);

    /// <summary>
    /// Gets the B23 register.
    /// </summary>
    public static Arm64RegisterB B23 => new(23);

    /// <summary>
    /// Gets the B24 register.
    /// </summary>
    public static Arm64RegisterB B24 => new(24);

    /// <summary>
    /// Gets the B25 register.
    /// </summary>
    public static Arm64RegisterB B25 => new(25);

    /// <summary>
    /// Gets the B26 register.
    /// </summary>
    public static Arm64RegisterB B26 => new(26);

    /// <summary>
    /// Gets the B27 register.
    /// </summary>
    public static Arm64RegisterB B27 => new(27);

    /// <summary>
    /// Gets the B28 register.
    /// </summary>
    public static Arm64RegisterB B28 => new(28);

    /// <summary>
    /// Gets the B29 register.
    /// </summary>
    public static Arm64RegisterB B29 => new(29);

    /// <summary>
    /// Gets the B30 register.
    /// </summary>
    public static Arm64RegisterB B30 => new(30);

    /// <summary>
    /// Gets the B31 register.
    /// </summary>
    public static Arm64RegisterB B31 => new(31);
}


/// <summary>
/// Represents an ARM64 an arranged 2 x B, 8-bit vector register
/// </summary>
public readonly record struct Arm64RegisterV_2B : IArm64RegisterVPacked
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_2B(int index) => _value = (2U << 24) | ((uint)Arm64RegisterVKind.B << 16) | ((uint)Arm64RegisterKind.VPacked << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public int ElementCount => Arm64RegisterAny.ToElementCount((_value >> 24) & 0xF);

    /// <summary>
    /// Gets the base register of this vector packed register.
    /// </summary>
    public Arm64RegisterV_B BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_2B register) => Unsafe.BitCast<Arm64RegisterV_2B, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.B register.
    /// </summary>
    public static explicit operator Arm64RegisterV_2B(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VPacked || register.VKind != Arm64RegisterVKind.B)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_2B");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_2B>(register);
    }

    /// <summary>
    /// Gets the indexed element of this vector packed register.
    /// </summary>
    public Indexed this[int elementIndex] => new(Index, elementIndex);

    /// <summary>
    /// Represents an ARM64 a vector indexed with (V.B arrangement).
    /// </summary>
    public readonly record struct Indexed : IArm64RegisterVPacked, IArm64RegisterVIndexed
    {
        private readonly uint _value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal Indexed(int registerIndex, int elementIndex) => _value = ((uint)elementIndex << 28) | (2U << 24) | ((uint)Arm64RegisterVKind.B << 16) | ((uint)Arm64RegisterKind.VPackedIndexed << 8) | (uint)registerIndex;

        /// <inheritdoc />
        public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

        /// <inheritdoc />
        public int Index => (byte)_value;

        /// <inheritdoc />
        public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

        /// <inheritdoc />
        public int ElementCount => (byte)((_value >> 24) & 0xF) << 1;

        /// <inheritdoc />
        public int ElementIndex => (byte)(_value >> 28);

        /// <summary>
        /// Gets the base register of this indexed vector register.
        /// </summary>
        public Arm64RegisterV_2B BaseRegister => new(Index);

        /// <inheritdoc />
        public override string ToString() => ToString(null, null);

        /// <inheritdoc />
        [SkipLocalsInit]
        public string ToString(string? format, IFormatProvider? formatProvider)
        {
            Span<char> localText = stackalloc char[16];
            return !TryFormat(localText, out var charsWritten, format, formatProvider) ? string.Empty : localText.Slice(0, charsWritten).ToString();
        }

        /// <inheritdoc />
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            if (!BaseRegister.TryFormat(destination, out var tempWritten, format, provider))
            {
                charsWritten = 0;
                return false;
            }
            // [1] to [16] (3 to 4 characters)
            if (destination.Length < tempWritten + 4)
            {
                charsWritten = 0;
                return false;
            }
            destination[tempWritten] = '[';
            if (ElementIndex >= 10)
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex / 10);
                destination[tempWritten + 2] = (char)('0' + ElementIndex % 10);
                charsWritten = tempWritten + 3;
            }
            else
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex);
                charsWritten = tempWritten + 2;
            }
            destination[charsWritten] = ']';

            charsWritten++;
            return true;
        }

        /// <summary>
        /// Converts this register to an any register.
        /// </summary>
        public static implicit operator Arm64RegisterAny(Indexed register) => Unsafe.BitCast<Indexed, Arm64RegisterAny>(register);

        /// <summary>
        /// Converts an any register to a V.B register.
        /// </summary>
        public static explicit operator Indexed(Arm64RegisterAny register)
        {
            if (register.Kind != Arm64RegisterKind.VPackedIndexed || register.VKind != Arm64RegisterVKind.B)
            {
                throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_2B.Indexed");
            }
            return Unsafe.BitCast<Arm64RegisterAny, Indexed>(register);
        }
    }
}

/// <summary>
/// Represents an ARM64 an arranged 4 x B, 8-bit vector register
/// </summary>
public readonly record struct Arm64RegisterV_4B : IArm64RegisterVPacked
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_4B(int index) => _value = (3U << 24) | ((uint)Arm64RegisterVKind.B << 16) | ((uint)Arm64RegisterKind.VPacked << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public int ElementCount => Arm64RegisterAny.ToElementCount((_value >> 24) & 0xF);

    /// <summary>
    /// Gets the base register of this vector packed register.
    /// </summary>
    public Arm64RegisterV_B BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_4B register) => Unsafe.BitCast<Arm64RegisterV_4B, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.B register.
    /// </summary>
    public static explicit operator Arm64RegisterV_4B(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VPacked || register.VKind != Arm64RegisterVKind.B)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_4B");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_4B>(register);
    }

    /// <summary>
    /// Gets the indexed element of this vector packed register.
    /// </summary>
    public Indexed this[int elementIndex] => new(Index, elementIndex);

    /// <summary>
    /// Represents an ARM64 a vector indexed with (V.B arrangement).
    /// </summary>
    public readonly record struct Indexed : IArm64RegisterVPacked, IArm64RegisterVIndexed
    {
        private readonly uint _value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal Indexed(int registerIndex, int elementIndex) => _value = ((uint)elementIndex << 28) | (3U << 24) | ((uint)Arm64RegisterVKind.B << 16) | ((uint)Arm64RegisterKind.VPackedIndexed << 8) | (uint)registerIndex;

        /// <inheritdoc />
        public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

        /// <inheritdoc />
        public int Index => (byte)_value;

        /// <inheritdoc />
        public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

        /// <inheritdoc />
        public int ElementCount => (byte)((_value >> 24) & 0xF) << 1;

        /// <inheritdoc />
        public int ElementIndex => (byte)(_value >> 28);

        /// <summary>
        /// Gets the base register of this indexed vector register.
        /// </summary>
        public Arm64RegisterV_4B BaseRegister => new(Index);

        /// <inheritdoc />
        public override string ToString() => ToString(null, null);

        /// <inheritdoc />
        [SkipLocalsInit]
        public string ToString(string? format, IFormatProvider? formatProvider)
        {
            Span<char> localText = stackalloc char[16];
            return !TryFormat(localText, out var charsWritten, format, formatProvider) ? string.Empty : localText.Slice(0, charsWritten).ToString();
        }

        /// <inheritdoc />
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            if (!BaseRegister.TryFormat(destination, out var tempWritten, format, provider))
            {
                charsWritten = 0;
                return false;
            }
            // [1] to [16] (3 to 4 characters)
            if (destination.Length < tempWritten + 4)
            {
                charsWritten = 0;
                return false;
            }
            destination[tempWritten] = '[';
            if (ElementIndex >= 10)
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex / 10);
                destination[tempWritten + 2] = (char)('0' + ElementIndex % 10);
                charsWritten = tempWritten + 3;
            }
            else
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex);
                charsWritten = tempWritten + 2;
            }
            destination[charsWritten] = ']';

            charsWritten++;
            return true;
        }

        /// <summary>
        /// Converts this register to an any register.
        /// </summary>
        public static implicit operator Arm64RegisterAny(Indexed register) => Unsafe.BitCast<Indexed, Arm64RegisterAny>(register);

        /// <summary>
        /// Converts an any register to a V.B register.
        /// </summary>
        public static explicit operator Indexed(Arm64RegisterAny register)
        {
            if (register.Kind != Arm64RegisterKind.VPackedIndexed || register.VKind != Arm64RegisterVKind.B)
            {
                throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_4B.Indexed");
            }
            return Unsafe.BitCast<Arm64RegisterAny, Indexed>(register);
        }
    }
}

/// <summary>
/// Represents an ARM64 an arranged 8 x B, 8-bit vector register
/// </summary>
public readonly record struct Arm64RegisterV_8B : IArm64RegisterVPacked
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_8B(int index) => _value = (4U << 24) | ((uint)Arm64RegisterVKind.B << 16) | ((uint)Arm64RegisterKind.VPacked << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public int ElementCount => Arm64RegisterAny.ToElementCount((_value >> 24) & 0xF);

    /// <summary>
    /// Gets the base register of this vector packed register.
    /// </summary>
    public Arm64RegisterV_B BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_8B register) => Unsafe.BitCast<Arm64RegisterV_8B, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.B register.
    /// </summary>
    public static explicit operator Arm64RegisterV_8B(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VPacked || register.VKind != Arm64RegisterVKind.B)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_8B");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_8B>(register);
    }
}

/// <summary>
/// Represents an ARM64 an arranged 16 x B, 8-bit vector register
/// </summary>
public readonly record struct Arm64RegisterV_16B : IArm64RegisterVPacked
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_16B(int index) => _value = (5U << 24) | ((uint)Arm64RegisterVKind.B << 16) | ((uint)Arm64RegisterKind.VPacked << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public int ElementCount => Arm64RegisterAny.ToElementCount((_value >> 24) & 0xF);

    /// <summary>
    /// Gets the base register of this vector packed register.
    /// </summary>
    public Arm64RegisterV_B BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_16B register) => Unsafe.BitCast<Arm64RegisterV_16B, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.B register.
    /// </summary>
    public static explicit operator Arm64RegisterV_16B(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VPacked || register.VKind != Arm64RegisterVKind.B)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_16B");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_16B>(register);
    }
}
/// <summary>
/// Represents an ARM64 a vector typed with Half-precision 16-bit floating-point register (V.H arrangement).
/// </summary>
public readonly record struct Arm64RegisterV_H : IArm64RegisterVTyped
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_H(int index) => _value = ((uint)Arm64RegisterVKind.H << 16) | ((uint)Arm64RegisterKind.VTyped << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <summary>
    /// Gets the indexed element of this vector typed register.
    /// </summary>
    public Indexed this[int elementIndex] => new(Index, elementIndex);

    /// <summary>
    /// Gets the base register of this vector typed register.
    /// </summary>
    public Arm64RegisterV BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_H register) => Unsafe.BitCast<Arm64RegisterV_H, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.H register.
    /// </summary>
    public static explicit operator Arm64RegisterV_H(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VTyped || register.VKind != Arm64RegisterVKind.H)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_H");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_H>(register);
    }

    /// <summary>
    /// Represents an ARM64 a vector indexed with Half-precision 16-bit floating-point register (V.H arrangement).
    /// </summary>
    public readonly record struct Indexed : IArm64RegisterVTyped, IArm64RegisterVIndexed
    {
        private readonly uint _value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal Indexed(int registerIndex, int elementIndex) => _value = ((uint)elementIndex << 28) | ((uint)Arm64RegisterVKind.H << 16) | ((uint)Arm64RegisterKind.VTypedIndexed << 8) | (uint)registerIndex;

        /// <inheritdoc />
        public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

        /// <inheritdoc />
        public int Index => (byte)_value;

        /// <inheritdoc />
        public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

        /// <inheritdoc />
        public int ElementIndex => (byte)(_value >> 28);

        /// <summary>
        /// Gets the base register of this indexed vector register.
        /// </summary>
        public Arm64RegisterV_H BaseRegister => new(Index);

        /// <inheritdoc />
        public override string ToString() => ToString(null, null);

        /// <inheritdoc />
        [SkipLocalsInit]
        public string ToString(string? format, IFormatProvider? formatProvider)
        {
            Span<char> localText = stackalloc char[16];
            return !TryFormat(localText, out var charsWritten, format, formatProvider) ? string.Empty : localText.Slice(0, charsWritten).ToString();
        }

        /// <inheritdoc />
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            if (!BaseRegister.TryFormat(destination, out var tempWritten, format, provider))
            {
                charsWritten = 0;
                return false;
            }
            // [1] to [16] (3 to 4 characters)
            if (destination.Length < tempWritten + 4)
            {
                charsWritten = 0;
                return false;
            }
            destination[tempWritten] = '[';
            if (ElementIndex >= 10)
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex / 10);
                destination[tempWritten + 2] = (char)('0' + ElementIndex % 10);
                charsWritten = tempWritten + 3;
            }
            else
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex);
                charsWritten = tempWritten + 2;
            }
            destination[charsWritten] = ']';

            charsWritten++;
            return true;
        }

        /// <summary>
        /// Converts this register to an any register.
        /// </summary>
        public static implicit operator Arm64RegisterAny(Indexed register) => Unsafe.BitCast<Indexed, Arm64RegisterAny>(register);

        /// <summary>
        /// Converts an any register to a V.H register.
        /// </summary>
        public static explicit operator Indexed(Arm64RegisterAny register)
        {
            if (register.Kind != Arm64RegisterKind.VTypedIndexed || register.VKind != Arm64RegisterVKind.H)
            {
                throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_H.Indexed");
            }
            return Unsafe.BitCast<Arm64RegisterAny, Indexed>(register);
        }
    }
}

/// <summary>
/// Represents an ARM64 a Half-precision 16-bit floating-point register (H arrangement).
/// </summary>
public readonly record struct Arm64RegisterH : IArm64RegisterVScalar
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterH(int index) => _value = ((uint)Arm64RegisterVKind.H << 16) | ((uint)Arm64RegisterKind.VScalar << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterH register) => Unsafe.BitCast<Arm64RegisterH, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.H register.
    /// </summary>
    public static explicit operator Arm64RegisterH(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VScalar || register.VKind != Arm64RegisterVKind.H)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterH");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterH>(register);
    }

    /// <summary>
    /// Gets the H0 register.
    /// </summary>
    public static Arm64RegisterH H0 => new(0);

    /// <summary>
    /// Gets the H1 register.
    /// </summary>
    public static Arm64RegisterH H1 => new(1);

    /// <summary>
    /// Gets the H2 register.
    /// </summary>
    public static Arm64RegisterH H2 => new(2);

    /// <summary>
    /// Gets the H3 register.
    /// </summary>
    public static Arm64RegisterH H3 => new(3);

    /// <summary>
    /// Gets the H4 register.
    /// </summary>
    public static Arm64RegisterH H4 => new(4);

    /// <summary>
    /// Gets the H5 register.
    /// </summary>
    public static Arm64RegisterH H5 => new(5);

    /// <summary>
    /// Gets the H6 register.
    /// </summary>
    public static Arm64RegisterH H6 => new(6);

    /// <summary>
    /// Gets the H7 register.
    /// </summary>
    public static Arm64RegisterH H7 => new(7);

    /// <summary>
    /// Gets the H8 register.
    /// </summary>
    public static Arm64RegisterH H8 => new(8);

    /// <summary>
    /// Gets the H9 register.
    /// </summary>
    public static Arm64RegisterH H9 => new(9);

    /// <summary>
    /// Gets the H10 register.
    /// </summary>
    public static Arm64RegisterH H10 => new(10);

    /// <summary>
    /// Gets the H11 register.
    /// </summary>
    public static Arm64RegisterH H11 => new(11);

    /// <summary>
    /// Gets the H12 register.
    /// </summary>
    public static Arm64RegisterH H12 => new(12);

    /// <summary>
    /// Gets the H13 register.
    /// </summary>
    public static Arm64RegisterH H13 => new(13);

    /// <summary>
    /// Gets the H14 register.
    /// </summary>
    public static Arm64RegisterH H14 => new(14);

    /// <summary>
    /// Gets the H15 register.
    /// </summary>
    public static Arm64RegisterH H15 => new(15);

    /// <summary>
    /// Gets the H16 register.
    /// </summary>
    public static Arm64RegisterH H16 => new(16);

    /// <summary>
    /// Gets the H17 register.
    /// </summary>
    public static Arm64RegisterH H17 => new(17);

    /// <summary>
    /// Gets the H18 register.
    /// </summary>
    public static Arm64RegisterH H18 => new(18);

    /// <summary>
    /// Gets the H19 register.
    /// </summary>
    public static Arm64RegisterH H19 => new(19);

    /// <summary>
    /// Gets the H20 register.
    /// </summary>
    public static Arm64RegisterH H20 => new(20);

    /// <summary>
    /// Gets the H21 register.
    /// </summary>
    public static Arm64RegisterH H21 => new(21);

    /// <summary>
    /// Gets the H22 register.
    /// </summary>
    public static Arm64RegisterH H22 => new(22);

    /// <summary>
    /// Gets the H23 register.
    /// </summary>
    public static Arm64RegisterH H23 => new(23);

    /// <summary>
    /// Gets the H24 register.
    /// </summary>
    public static Arm64RegisterH H24 => new(24);

    /// <summary>
    /// Gets the H25 register.
    /// </summary>
    public static Arm64RegisterH H25 => new(25);

    /// <summary>
    /// Gets the H26 register.
    /// </summary>
    public static Arm64RegisterH H26 => new(26);

    /// <summary>
    /// Gets the H27 register.
    /// </summary>
    public static Arm64RegisterH H27 => new(27);

    /// <summary>
    /// Gets the H28 register.
    /// </summary>
    public static Arm64RegisterH H28 => new(28);

    /// <summary>
    /// Gets the H29 register.
    /// </summary>
    public static Arm64RegisterH H29 => new(29);

    /// <summary>
    /// Gets the H30 register.
    /// </summary>
    public static Arm64RegisterH H30 => new(30);

    /// <summary>
    /// Gets the H31 register.
    /// </summary>
    public static Arm64RegisterH H31 => new(31);
}


/// <summary>
/// Represents an ARM64 an arranged 2 x H, Half-precision 16-bit floating-point register
/// </summary>
public readonly record struct Arm64RegisterV_2H : IArm64RegisterVPacked
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_2H(int index) => _value = (2U << 24) | ((uint)Arm64RegisterVKind.H << 16) | ((uint)Arm64RegisterKind.VPacked << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public int ElementCount => Arm64RegisterAny.ToElementCount((_value >> 24) & 0xF);

    /// <summary>
    /// Gets the base register of this vector packed register.
    /// </summary>
    public Arm64RegisterV_H BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_2H register) => Unsafe.BitCast<Arm64RegisterV_2H, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.H register.
    /// </summary>
    public static explicit operator Arm64RegisterV_2H(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VPacked || register.VKind != Arm64RegisterVKind.H)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_2H");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_2H>(register);
    }

    /// <summary>
    /// Gets the indexed element of this vector packed register.
    /// </summary>
    public Indexed this[int elementIndex] => new(Index, elementIndex);

    /// <summary>
    /// Represents an ARM64 a vector indexed with (V.H arrangement).
    /// </summary>
    public readonly record struct Indexed : IArm64RegisterVPacked, IArm64RegisterVIndexed
    {
        private readonly uint _value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal Indexed(int registerIndex, int elementIndex) => _value = ((uint)elementIndex << 28) | (2U << 24) | ((uint)Arm64RegisterVKind.H << 16) | ((uint)Arm64RegisterKind.VPackedIndexed << 8) | (uint)registerIndex;

        /// <inheritdoc />
        public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

        /// <inheritdoc />
        public int Index => (byte)_value;

        /// <inheritdoc />
        public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

        /// <inheritdoc />
        public int ElementCount => (byte)((_value >> 24) & 0xF) << 1;

        /// <inheritdoc />
        public int ElementIndex => (byte)(_value >> 28);

        /// <summary>
        /// Gets the base register of this indexed vector register.
        /// </summary>
        public Arm64RegisterV_2H BaseRegister => new(Index);

        /// <inheritdoc />
        public override string ToString() => ToString(null, null);

        /// <inheritdoc />
        [SkipLocalsInit]
        public string ToString(string? format, IFormatProvider? formatProvider)
        {
            Span<char> localText = stackalloc char[16];
            return !TryFormat(localText, out var charsWritten, format, formatProvider) ? string.Empty : localText.Slice(0, charsWritten).ToString();
        }

        /// <inheritdoc />
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            if (!BaseRegister.TryFormat(destination, out var tempWritten, format, provider))
            {
                charsWritten = 0;
                return false;
            }
            // [1] to [16] (3 to 4 characters)
            if (destination.Length < tempWritten + 4)
            {
                charsWritten = 0;
                return false;
            }
            destination[tempWritten] = '[';
            if (ElementIndex >= 10)
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex / 10);
                destination[tempWritten + 2] = (char)('0' + ElementIndex % 10);
                charsWritten = tempWritten + 3;
            }
            else
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex);
                charsWritten = tempWritten + 2;
            }
            destination[charsWritten] = ']';

            charsWritten++;
            return true;
        }

        /// <summary>
        /// Converts this register to an any register.
        /// </summary>
        public static implicit operator Arm64RegisterAny(Indexed register) => Unsafe.BitCast<Indexed, Arm64RegisterAny>(register);

        /// <summary>
        /// Converts an any register to a V.H register.
        /// </summary>
        public static explicit operator Indexed(Arm64RegisterAny register)
        {
            if (register.Kind != Arm64RegisterKind.VPackedIndexed || register.VKind != Arm64RegisterVKind.H)
            {
                throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_2H.Indexed");
            }
            return Unsafe.BitCast<Arm64RegisterAny, Indexed>(register);
        }
    }
}

/// <summary>
/// Represents an ARM64 an arranged 4 x H, Half-precision 16-bit floating-point register
/// </summary>
public readonly record struct Arm64RegisterV_4H : IArm64RegisterVPacked
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_4H(int index) => _value = (3U << 24) | ((uint)Arm64RegisterVKind.H << 16) | ((uint)Arm64RegisterKind.VPacked << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public int ElementCount => Arm64RegisterAny.ToElementCount((_value >> 24) & 0xF);

    /// <summary>
    /// Gets the base register of this vector packed register.
    /// </summary>
    public Arm64RegisterV_H BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_4H register) => Unsafe.BitCast<Arm64RegisterV_4H, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.H register.
    /// </summary>
    public static explicit operator Arm64RegisterV_4H(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VPacked || register.VKind != Arm64RegisterVKind.H)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_4H");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_4H>(register);
    }
}

/// <summary>
/// Represents an ARM64 an arranged 8 x H, Half-precision 16-bit floating-point register
/// </summary>
public readonly record struct Arm64RegisterV_8H : IArm64RegisterVPacked
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_8H(int index) => _value = (4U << 24) | ((uint)Arm64RegisterVKind.H << 16) | ((uint)Arm64RegisterKind.VPacked << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public int ElementCount => Arm64RegisterAny.ToElementCount((_value >> 24) & 0xF);

    /// <summary>
    /// Gets the base register of this vector packed register.
    /// </summary>
    public Arm64RegisterV_H BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_8H register) => Unsafe.BitCast<Arm64RegisterV_8H, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.H register.
    /// </summary>
    public static explicit operator Arm64RegisterV_8H(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VPacked || register.VKind != Arm64RegisterVKind.H)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_8H");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_8H>(register);
    }
}
/// <summary>
/// Represents an ARM64 a vector typed with Single-precision 32-bit floating-point register (V.S arrangement).
/// </summary>
public readonly record struct Arm64RegisterV_S : IArm64RegisterVTyped
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_S(int index) => _value = ((uint)Arm64RegisterVKind.S << 16) | ((uint)Arm64RegisterKind.VTyped << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <summary>
    /// Gets the indexed element of this vector typed register.
    /// </summary>
    public Indexed this[int elementIndex] => new(Index, elementIndex);

    /// <summary>
    /// Gets the base register of this vector typed register.
    /// </summary>
    public Arm64RegisterV BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_S register) => Unsafe.BitCast<Arm64RegisterV_S, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.S register.
    /// </summary>
    public static explicit operator Arm64RegisterV_S(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VTyped || register.VKind != Arm64RegisterVKind.S)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_S");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_S>(register);
    }

    /// <summary>
    /// Represents an ARM64 a vector indexed with Single-precision 32-bit floating-point register (V.S arrangement).
    /// </summary>
    public readonly record struct Indexed : IArm64RegisterVTyped, IArm64RegisterVIndexed
    {
        private readonly uint _value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal Indexed(int registerIndex, int elementIndex) => _value = ((uint)elementIndex << 28) | ((uint)Arm64RegisterVKind.S << 16) | ((uint)Arm64RegisterKind.VTypedIndexed << 8) | (uint)registerIndex;

        /// <inheritdoc />
        public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

        /// <inheritdoc />
        public int Index => (byte)_value;

        /// <inheritdoc />
        public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

        /// <inheritdoc />
        public int ElementIndex => (byte)(_value >> 28);

        /// <summary>
        /// Gets the base register of this indexed vector register.
        /// </summary>
        public Arm64RegisterV_S BaseRegister => new(Index);

        /// <inheritdoc />
        public override string ToString() => ToString(null, null);

        /// <inheritdoc />
        [SkipLocalsInit]
        public string ToString(string? format, IFormatProvider? formatProvider)
        {
            Span<char> localText = stackalloc char[16];
            return !TryFormat(localText, out var charsWritten, format, formatProvider) ? string.Empty : localText.Slice(0, charsWritten).ToString();
        }

        /// <inheritdoc />
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            if (!BaseRegister.TryFormat(destination, out var tempWritten, format, provider))
            {
                charsWritten = 0;
                return false;
            }
            // [1] to [16] (3 to 4 characters)
            if (destination.Length < tempWritten + 4)
            {
                charsWritten = 0;
                return false;
            }
            destination[tempWritten] = '[';
            if (ElementIndex >= 10)
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex / 10);
                destination[tempWritten + 2] = (char)('0' + ElementIndex % 10);
                charsWritten = tempWritten + 3;
            }
            else
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex);
                charsWritten = tempWritten + 2;
            }
            destination[charsWritten] = ']';

            charsWritten++;
            return true;
        }

        /// <summary>
        /// Converts this register to an any register.
        /// </summary>
        public static implicit operator Arm64RegisterAny(Indexed register) => Unsafe.BitCast<Indexed, Arm64RegisterAny>(register);

        /// <summary>
        /// Converts an any register to a V.S register.
        /// </summary>
        public static explicit operator Indexed(Arm64RegisterAny register)
        {
            if (register.Kind != Arm64RegisterKind.VTypedIndexed || register.VKind != Arm64RegisterVKind.S)
            {
                throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_S.Indexed");
            }
            return Unsafe.BitCast<Arm64RegisterAny, Indexed>(register);
        }
    }
}

/// <summary>
/// Represents an ARM64 a Single-precision 32-bit floating-point register (S arrangement).
/// </summary>
public readonly record struct Arm64RegisterS : IArm64RegisterVScalar
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterS(int index) => _value = ((uint)Arm64RegisterVKind.S << 16) | ((uint)Arm64RegisterKind.VScalar << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterS register) => Unsafe.BitCast<Arm64RegisterS, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.S register.
    /// </summary>
    public static explicit operator Arm64RegisterS(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VScalar || register.VKind != Arm64RegisterVKind.S)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterS");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterS>(register);
    }

    /// <summary>
    /// Gets the S0 register.
    /// </summary>
    public static Arm64RegisterS S0 => new(0);

    /// <summary>
    /// Gets the S1 register.
    /// </summary>
    public static Arm64RegisterS S1 => new(1);

    /// <summary>
    /// Gets the S2 register.
    /// </summary>
    public static Arm64RegisterS S2 => new(2);

    /// <summary>
    /// Gets the S3 register.
    /// </summary>
    public static Arm64RegisterS S3 => new(3);

    /// <summary>
    /// Gets the S4 register.
    /// </summary>
    public static Arm64RegisterS S4 => new(4);

    /// <summary>
    /// Gets the S5 register.
    /// </summary>
    public static Arm64RegisterS S5 => new(5);

    /// <summary>
    /// Gets the S6 register.
    /// </summary>
    public static Arm64RegisterS S6 => new(6);

    /// <summary>
    /// Gets the S7 register.
    /// </summary>
    public static Arm64RegisterS S7 => new(7);

    /// <summary>
    /// Gets the S8 register.
    /// </summary>
    public static Arm64RegisterS S8 => new(8);

    /// <summary>
    /// Gets the S9 register.
    /// </summary>
    public static Arm64RegisterS S9 => new(9);

    /// <summary>
    /// Gets the S10 register.
    /// </summary>
    public static Arm64RegisterS S10 => new(10);

    /// <summary>
    /// Gets the S11 register.
    /// </summary>
    public static Arm64RegisterS S11 => new(11);

    /// <summary>
    /// Gets the S12 register.
    /// </summary>
    public static Arm64RegisterS S12 => new(12);

    /// <summary>
    /// Gets the S13 register.
    /// </summary>
    public static Arm64RegisterS S13 => new(13);

    /// <summary>
    /// Gets the S14 register.
    /// </summary>
    public static Arm64RegisterS S14 => new(14);

    /// <summary>
    /// Gets the S15 register.
    /// </summary>
    public static Arm64RegisterS S15 => new(15);

    /// <summary>
    /// Gets the S16 register.
    /// </summary>
    public static Arm64RegisterS S16 => new(16);

    /// <summary>
    /// Gets the S17 register.
    /// </summary>
    public static Arm64RegisterS S17 => new(17);

    /// <summary>
    /// Gets the S18 register.
    /// </summary>
    public static Arm64RegisterS S18 => new(18);

    /// <summary>
    /// Gets the S19 register.
    /// </summary>
    public static Arm64RegisterS S19 => new(19);

    /// <summary>
    /// Gets the S20 register.
    /// </summary>
    public static Arm64RegisterS S20 => new(20);

    /// <summary>
    /// Gets the S21 register.
    /// </summary>
    public static Arm64RegisterS S21 => new(21);

    /// <summary>
    /// Gets the S22 register.
    /// </summary>
    public static Arm64RegisterS S22 => new(22);

    /// <summary>
    /// Gets the S23 register.
    /// </summary>
    public static Arm64RegisterS S23 => new(23);

    /// <summary>
    /// Gets the S24 register.
    /// </summary>
    public static Arm64RegisterS S24 => new(24);

    /// <summary>
    /// Gets the S25 register.
    /// </summary>
    public static Arm64RegisterS S25 => new(25);

    /// <summary>
    /// Gets the S26 register.
    /// </summary>
    public static Arm64RegisterS S26 => new(26);

    /// <summary>
    /// Gets the S27 register.
    /// </summary>
    public static Arm64RegisterS S27 => new(27);

    /// <summary>
    /// Gets the S28 register.
    /// </summary>
    public static Arm64RegisterS S28 => new(28);

    /// <summary>
    /// Gets the S29 register.
    /// </summary>
    public static Arm64RegisterS S29 => new(29);

    /// <summary>
    /// Gets the S30 register.
    /// </summary>
    public static Arm64RegisterS S30 => new(30);

    /// <summary>
    /// Gets the S31 register.
    /// </summary>
    public static Arm64RegisterS S31 => new(31);
}


/// <summary>
/// Represents an ARM64 an arranged 2 x S, Single-precision 32-bit floating-point register
/// </summary>
public readonly record struct Arm64RegisterV_2S : IArm64RegisterVPacked
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_2S(int index) => _value = (2U << 24) | ((uint)Arm64RegisterVKind.S << 16) | ((uint)Arm64RegisterKind.VPacked << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public int ElementCount => Arm64RegisterAny.ToElementCount((_value >> 24) & 0xF);

    /// <summary>
    /// Gets the base register of this vector packed register.
    /// </summary>
    public Arm64RegisterV_S BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_2S register) => Unsafe.BitCast<Arm64RegisterV_2S, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.S register.
    /// </summary>
    public static explicit operator Arm64RegisterV_2S(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VPacked || register.VKind != Arm64RegisterVKind.S)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_2S");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_2S>(register);
    }
}

/// <summary>
/// Represents an ARM64 an arranged 4 x S, Single-precision 32-bit floating-point register
/// </summary>
public readonly record struct Arm64RegisterV_4S : IArm64RegisterVPacked
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_4S(int index) => _value = (3U << 24) | ((uint)Arm64RegisterVKind.S << 16) | ((uint)Arm64RegisterKind.VPacked << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public int ElementCount => Arm64RegisterAny.ToElementCount((_value >> 24) & 0xF);

    /// <summary>
    /// Gets the base register of this vector packed register.
    /// </summary>
    public Arm64RegisterV_S BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_4S register) => Unsafe.BitCast<Arm64RegisterV_4S, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.S register.
    /// </summary>
    public static explicit operator Arm64RegisterV_4S(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VPacked || register.VKind != Arm64RegisterVKind.S)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_4S");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_4S>(register);
    }
}
/// <summary>
/// Represents an ARM64 a vector typed with Double-precision 64-bit floating-point register (V.D arrangement).
/// </summary>
public readonly record struct Arm64RegisterV_D : IArm64RegisterVTyped
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_D(int index) => _value = ((uint)Arm64RegisterVKind.D << 16) | ((uint)Arm64RegisterKind.VTyped << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <summary>
    /// Gets the indexed element of this vector typed register.
    /// </summary>
    public Indexed this[int elementIndex] => new(Index, elementIndex);

    /// <summary>
    /// Gets the base register of this vector typed register.
    /// </summary>
    public Arm64RegisterV BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_D register) => Unsafe.BitCast<Arm64RegisterV_D, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.D register.
    /// </summary>
    public static explicit operator Arm64RegisterV_D(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VTyped || register.VKind != Arm64RegisterVKind.D)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_D");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_D>(register);
    }

    /// <summary>
    /// Represents an ARM64 a vector indexed with Double-precision 64-bit floating-point register (V.D arrangement).
    /// </summary>
    public readonly record struct Indexed : IArm64RegisterVTyped, IArm64RegisterVIndexed
    {
        private readonly uint _value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal Indexed(int registerIndex, int elementIndex) => _value = ((uint)elementIndex << 28) | ((uint)Arm64RegisterVKind.D << 16) | ((uint)Arm64RegisterKind.VTypedIndexed << 8) | (uint)registerIndex;

        /// <inheritdoc />
        public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

        /// <inheritdoc />
        public int Index => (byte)_value;

        /// <inheritdoc />
        public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

        /// <inheritdoc />
        public int ElementIndex => (byte)(_value >> 28);

        /// <summary>
        /// Gets the base register of this indexed vector register.
        /// </summary>
        public Arm64RegisterV_D BaseRegister => new(Index);

        /// <inheritdoc />
        public override string ToString() => ToString(null, null);

        /// <inheritdoc />
        [SkipLocalsInit]
        public string ToString(string? format, IFormatProvider? formatProvider)
        {
            Span<char> localText = stackalloc char[16];
            return !TryFormat(localText, out var charsWritten, format, formatProvider) ? string.Empty : localText.Slice(0, charsWritten).ToString();
        }

        /// <inheritdoc />
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            if (!BaseRegister.TryFormat(destination, out var tempWritten, format, provider))
            {
                charsWritten = 0;
                return false;
            }
            // [1] to [16] (3 to 4 characters)
            if (destination.Length < tempWritten + 4)
            {
                charsWritten = 0;
                return false;
            }
            destination[tempWritten] = '[';
            if (ElementIndex >= 10)
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex / 10);
                destination[tempWritten + 2] = (char)('0' + ElementIndex % 10);
                charsWritten = tempWritten + 3;
            }
            else
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex);
                charsWritten = tempWritten + 2;
            }
            destination[charsWritten] = ']';

            charsWritten++;
            return true;
        }

        /// <summary>
        /// Converts this register to an any register.
        /// </summary>
        public static implicit operator Arm64RegisterAny(Indexed register) => Unsafe.BitCast<Indexed, Arm64RegisterAny>(register);

        /// <summary>
        /// Converts an any register to a V.D register.
        /// </summary>
        public static explicit operator Indexed(Arm64RegisterAny register)
        {
            if (register.Kind != Arm64RegisterKind.VTypedIndexed || register.VKind != Arm64RegisterVKind.D)
            {
                throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_D.Indexed");
            }
            return Unsafe.BitCast<Arm64RegisterAny, Indexed>(register);
        }
    }
}

/// <summary>
/// Represents an ARM64 a Double-precision 64-bit floating-point register (D arrangement).
/// </summary>
public readonly record struct Arm64RegisterD : IArm64RegisterVScalar
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterD(int index) => _value = ((uint)Arm64RegisterVKind.D << 16) | ((uint)Arm64RegisterKind.VScalar << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterD register) => Unsafe.BitCast<Arm64RegisterD, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.D register.
    /// </summary>
    public static explicit operator Arm64RegisterD(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VScalar || register.VKind != Arm64RegisterVKind.D)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterD");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterD>(register);
    }

    /// <summary>
    /// Gets the D0 register.
    /// </summary>
    public static Arm64RegisterD D0 => new(0);

    /// <summary>
    /// Gets the D1 register.
    /// </summary>
    public static Arm64RegisterD D1 => new(1);

    /// <summary>
    /// Gets the D2 register.
    /// </summary>
    public static Arm64RegisterD D2 => new(2);

    /// <summary>
    /// Gets the D3 register.
    /// </summary>
    public static Arm64RegisterD D3 => new(3);

    /// <summary>
    /// Gets the D4 register.
    /// </summary>
    public static Arm64RegisterD D4 => new(4);

    /// <summary>
    /// Gets the D5 register.
    /// </summary>
    public static Arm64RegisterD D5 => new(5);

    /// <summary>
    /// Gets the D6 register.
    /// </summary>
    public static Arm64RegisterD D6 => new(6);

    /// <summary>
    /// Gets the D7 register.
    /// </summary>
    public static Arm64RegisterD D7 => new(7);

    /// <summary>
    /// Gets the D8 register.
    /// </summary>
    public static Arm64RegisterD D8 => new(8);

    /// <summary>
    /// Gets the D9 register.
    /// </summary>
    public static Arm64RegisterD D9 => new(9);

    /// <summary>
    /// Gets the D10 register.
    /// </summary>
    public static Arm64RegisterD D10 => new(10);

    /// <summary>
    /// Gets the D11 register.
    /// </summary>
    public static Arm64RegisterD D11 => new(11);

    /// <summary>
    /// Gets the D12 register.
    /// </summary>
    public static Arm64RegisterD D12 => new(12);

    /// <summary>
    /// Gets the D13 register.
    /// </summary>
    public static Arm64RegisterD D13 => new(13);

    /// <summary>
    /// Gets the D14 register.
    /// </summary>
    public static Arm64RegisterD D14 => new(14);

    /// <summary>
    /// Gets the D15 register.
    /// </summary>
    public static Arm64RegisterD D15 => new(15);

    /// <summary>
    /// Gets the D16 register.
    /// </summary>
    public static Arm64RegisterD D16 => new(16);

    /// <summary>
    /// Gets the D17 register.
    /// </summary>
    public static Arm64RegisterD D17 => new(17);

    /// <summary>
    /// Gets the D18 register.
    /// </summary>
    public static Arm64RegisterD D18 => new(18);

    /// <summary>
    /// Gets the D19 register.
    /// </summary>
    public static Arm64RegisterD D19 => new(19);

    /// <summary>
    /// Gets the D20 register.
    /// </summary>
    public static Arm64RegisterD D20 => new(20);

    /// <summary>
    /// Gets the D21 register.
    /// </summary>
    public static Arm64RegisterD D21 => new(21);

    /// <summary>
    /// Gets the D22 register.
    /// </summary>
    public static Arm64RegisterD D22 => new(22);

    /// <summary>
    /// Gets the D23 register.
    /// </summary>
    public static Arm64RegisterD D23 => new(23);

    /// <summary>
    /// Gets the D24 register.
    /// </summary>
    public static Arm64RegisterD D24 => new(24);

    /// <summary>
    /// Gets the D25 register.
    /// </summary>
    public static Arm64RegisterD D25 => new(25);

    /// <summary>
    /// Gets the D26 register.
    /// </summary>
    public static Arm64RegisterD D26 => new(26);

    /// <summary>
    /// Gets the D27 register.
    /// </summary>
    public static Arm64RegisterD D27 => new(27);

    /// <summary>
    /// Gets the D28 register.
    /// </summary>
    public static Arm64RegisterD D28 => new(28);

    /// <summary>
    /// Gets the D29 register.
    /// </summary>
    public static Arm64RegisterD D29 => new(29);

    /// <summary>
    /// Gets the D30 register.
    /// </summary>
    public static Arm64RegisterD D30 => new(30);

    /// <summary>
    /// Gets the D31 register.
    /// </summary>
    public static Arm64RegisterD D31 => new(31);
}


/// <summary>
/// Represents an ARM64 an arranged 1 x D, Double-precision 64-bit floating-point register
/// </summary>
public readonly record struct Arm64RegisterV_1D : IArm64RegisterVPacked
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_1D(int index) => _value = (1U << 24) | ((uint)Arm64RegisterVKind.D << 16) | ((uint)Arm64RegisterKind.VPacked << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public int ElementCount => Arm64RegisterAny.ToElementCount((_value >> 24) & 0xF);

    /// <summary>
    /// Gets the base register of this vector packed register.
    /// </summary>
    public Arm64RegisterV_D BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_1D register) => Unsafe.BitCast<Arm64RegisterV_1D, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.D register.
    /// </summary>
    public static explicit operator Arm64RegisterV_1D(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VPacked || register.VKind != Arm64RegisterVKind.D)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_1D");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_1D>(register);
    }
}

/// <summary>
/// Represents an ARM64 an arranged 2 x D, Double-precision 64-bit floating-point register
/// </summary>
public readonly record struct Arm64RegisterV_2D : IArm64RegisterVPacked
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_2D(int index) => _value = (2U << 24) | ((uint)Arm64RegisterVKind.D << 16) | ((uint)Arm64RegisterKind.VPacked << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public int ElementCount => Arm64RegisterAny.ToElementCount((_value >> 24) & 0xF);

    /// <summary>
    /// Gets the base register of this vector packed register.
    /// </summary>
    public Arm64RegisterV_D BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_2D register) => Unsafe.BitCast<Arm64RegisterV_2D, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.D register.
    /// </summary>
    public static explicit operator Arm64RegisterV_2D(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VPacked || register.VKind != Arm64RegisterVKind.D)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_2D");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_2D>(register);
    }
}
/// <summary>
/// Represents an ARM64 a vector typed with Double-precision 64-bit floating-point register (V.Q arrangement).
/// </summary>
public readonly record struct Arm64RegisterV_Q : IArm64RegisterVTyped
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_Q(int index) => _value = ((uint)Arm64RegisterVKind.Q << 16) | ((uint)Arm64RegisterKind.VTyped << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <summary>
    /// Gets the indexed element of this vector typed register.
    /// </summary>
    public Indexed this[int elementIndex] => new(Index, elementIndex);

    /// <summary>
    /// Gets the base register of this vector typed register.
    /// </summary>
    public Arm64RegisterV BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_Q register) => Unsafe.BitCast<Arm64RegisterV_Q, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.Q register.
    /// </summary>
    public static explicit operator Arm64RegisterV_Q(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VTyped || register.VKind != Arm64RegisterVKind.Q)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_Q");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_Q>(register);
    }

    /// <summary>
    /// Represents an ARM64 a vector indexed with Double-precision 64-bit floating-point register (V.Q arrangement).
    /// </summary>
    public readonly record struct Indexed : IArm64RegisterVTyped, IArm64RegisterVIndexed
    {
        private readonly uint _value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal Indexed(int registerIndex, int elementIndex) => _value = ((uint)elementIndex << 28) | ((uint)Arm64RegisterVKind.Q << 16) | ((uint)Arm64RegisterKind.VTypedIndexed << 8) | (uint)registerIndex;

        /// <inheritdoc />
        public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

        /// <inheritdoc />
        public int Index => (byte)_value;

        /// <inheritdoc />
        public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

        /// <inheritdoc />
        public int ElementIndex => (byte)(_value >> 28);

        /// <summary>
        /// Gets the base register of this indexed vector register.
        /// </summary>
        public Arm64RegisterV_Q BaseRegister => new(Index);

        /// <inheritdoc />
        public override string ToString() => ToString(null, null);

        /// <inheritdoc />
        [SkipLocalsInit]
        public string ToString(string? format, IFormatProvider? formatProvider)
        {
            Span<char> localText = stackalloc char[16];
            return !TryFormat(localText, out var charsWritten, format, formatProvider) ? string.Empty : localText.Slice(0, charsWritten).ToString();
        }

        /// <inheritdoc />
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            if (!BaseRegister.TryFormat(destination, out var tempWritten, format, provider))
            {
                charsWritten = 0;
                return false;
            }
            // [1] to [16] (3 to 4 characters)
            if (destination.Length < tempWritten + 4)
            {
                charsWritten = 0;
                return false;
            }
            destination[tempWritten] = '[';
            if (ElementIndex >= 10)
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex / 10);
                destination[tempWritten + 2] = (char)('0' + ElementIndex % 10);
                charsWritten = tempWritten + 3;
            }
            else
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex);
                charsWritten = tempWritten + 2;
            }
            destination[charsWritten] = ']';

            charsWritten++;
            return true;
        }

        /// <summary>
        /// Converts this register to an any register.
        /// </summary>
        public static implicit operator Arm64RegisterAny(Indexed register) => Unsafe.BitCast<Indexed, Arm64RegisterAny>(register);

        /// <summary>
        /// Converts an any register to a V.Q register.
        /// </summary>
        public static explicit operator Indexed(Arm64RegisterAny register)
        {
            if (register.Kind != Arm64RegisterKind.VTypedIndexed || register.VKind != Arm64RegisterVKind.Q)
            {
                throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_Q.Indexed");
            }
            return Unsafe.BitCast<Arm64RegisterAny, Indexed>(register);
        }
    }
}

/// <summary>
/// Represents an ARM64 a Double-precision 64-bit floating-point register (Q arrangement).
/// </summary>
public readonly record struct Arm64RegisterQ : IArm64RegisterVScalar
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterQ(int index) => _value = ((uint)Arm64RegisterVKind.Q << 16) | ((uint)Arm64RegisterKind.VScalar << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterQ register) => Unsafe.BitCast<Arm64RegisterQ, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.Q register.
    /// </summary>
    public static explicit operator Arm64RegisterQ(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VScalar || register.VKind != Arm64RegisterVKind.Q)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterQ");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterQ>(register);
    }

    /// <summary>
    /// Gets the Q0 register.
    /// </summary>
    public static Arm64RegisterQ Q0 => new(0);

    /// <summary>
    /// Gets the Q1 register.
    /// </summary>
    public static Arm64RegisterQ Q1 => new(1);

    /// <summary>
    /// Gets the Q2 register.
    /// </summary>
    public static Arm64RegisterQ Q2 => new(2);

    /// <summary>
    /// Gets the Q3 register.
    /// </summary>
    public static Arm64RegisterQ Q3 => new(3);

    /// <summary>
    /// Gets the Q4 register.
    /// </summary>
    public static Arm64RegisterQ Q4 => new(4);

    /// <summary>
    /// Gets the Q5 register.
    /// </summary>
    public static Arm64RegisterQ Q5 => new(5);

    /// <summary>
    /// Gets the Q6 register.
    /// </summary>
    public static Arm64RegisterQ Q6 => new(6);

    /// <summary>
    /// Gets the Q7 register.
    /// </summary>
    public static Arm64RegisterQ Q7 => new(7);

    /// <summary>
    /// Gets the Q8 register.
    /// </summary>
    public static Arm64RegisterQ Q8 => new(8);

    /// <summary>
    /// Gets the Q9 register.
    /// </summary>
    public static Arm64RegisterQ Q9 => new(9);

    /// <summary>
    /// Gets the Q10 register.
    /// </summary>
    public static Arm64RegisterQ Q10 => new(10);

    /// <summary>
    /// Gets the Q11 register.
    /// </summary>
    public static Arm64RegisterQ Q11 => new(11);

    /// <summary>
    /// Gets the Q12 register.
    /// </summary>
    public static Arm64RegisterQ Q12 => new(12);

    /// <summary>
    /// Gets the Q13 register.
    /// </summary>
    public static Arm64RegisterQ Q13 => new(13);

    /// <summary>
    /// Gets the Q14 register.
    /// </summary>
    public static Arm64RegisterQ Q14 => new(14);

    /// <summary>
    /// Gets the Q15 register.
    /// </summary>
    public static Arm64RegisterQ Q15 => new(15);

    /// <summary>
    /// Gets the Q16 register.
    /// </summary>
    public static Arm64RegisterQ Q16 => new(16);

    /// <summary>
    /// Gets the Q17 register.
    /// </summary>
    public static Arm64RegisterQ Q17 => new(17);

    /// <summary>
    /// Gets the Q18 register.
    /// </summary>
    public static Arm64RegisterQ Q18 => new(18);

    /// <summary>
    /// Gets the Q19 register.
    /// </summary>
    public static Arm64RegisterQ Q19 => new(19);

    /// <summary>
    /// Gets the Q20 register.
    /// </summary>
    public static Arm64RegisterQ Q20 => new(20);

    /// <summary>
    /// Gets the Q21 register.
    /// </summary>
    public static Arm64RegisterQ Q21 => new(21);

    /// <summary>
    /// Gets the Q22 register.
    /// </summary>
    public static Arm64RegisterQ Q22 => new(22);

    /// <summary>
    /// Gets the Q23 register.
    /// </summary>
    public static Arm64RegisterQ Q23 => new(23);

    /// <summary>
    /// Gets the Q24 register.
    /// </summary>
    public static Arm64RegisterQ Q24 => new(24);

    /// <summary>
    /// Gets the Q25 register.
    /// </summary>
    public static Arm64RegisterQ Q25 => new(25);

    /// <summary>
    /// Gets the Q26 register.
    /// </summary>
    public static Arm64RegisterQ Q26 => new(26);

    /// <summary>
    /// Gets the Q27 register.
    /// </summary>
    public static Arm64RegisterQ Q27 => new(27);

    /// <summary>
    /// Gets the Q28 register.
    /// </summary>
    public static Arm64RegisterQ Q28 => new(28);

    /// <summary>
    /// Gets the Q29 register.
    /// </summary>
    public static Arm64RegisterQ Q29 => new(29);

    /// <summary>
    /// Gets the Q30 register.
    /// </summary>
    public static Arm64RegisterQ Q30 => new(30);

    /// <summary>
    /// Gets the Q31 register.
    /// </summary>
    public static Arm64RegisterQ Q31 => new(31);
}


/// <summary>
/// Represents an ARM64 an arranged 1 x Q, Double-precision 64-bit floating-point register
/// </summary>
public readonly record struct Arm64RegisterV_1Q : IArm64RegisterVPacked
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_1Q(int index) => _value = (1U << 24) | ((uint)Arm64RegisterVKind.Q << 16) | ((uint)Arm64RegisterKind.VPacked << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public int ElementCount => Arm64RegisterAny.ToElementCount((_value >> 24) & 0xF);

    /// <summary>
    /// Gets the base register of this vector packed register.
    /// </summary>
    public Arm64RegisterV_Q BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_1Q register) => Unsafe.BitCast<Arm64RegisterV_1Q, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.Q register.
    /// </summary>
    public static explicit operator Arm64RegisterV_1Q(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VPacked || register.VKind != Arm64RegisterVKind.Q)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_1Q");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_1Q>(register);
    }
}

partial class Arm64Factory
{
    /// <summary>
    /// Gets the XZR register.
    /// </summary>
    public static Arm64RegisterX XZR => Arm64RegisterX.XZR;

        /// <summary>
    /// Gets the WZR register.
    /// </summary>
    public static Arm64RegisterW WZR => Arm64RegisterW.WZR;
    /// <summary>
    /// Gets the X0 register.
    /// </summary>
    public static Arm64RegisterX X0 => Arm64RegisterX.X0;
    /// <summary>
    /// Gets the X1 register.
    /// </summary>
    public static Arm64RegisterX X1 => Arm64RegisterX.X1;
    /// <summary>
    /// Gets the X2 register.
    /// </summary>
    public static Arm64RegisterX X2 => Arm64RegisterX.X2;
    /// <summary>
    /// Gets the X3 register.
    /// </summary>
    public static Arm64RegisterX X3 => Arm64RegisterX.X3;
    /// <summary>
    /// Gets the X4 register.
    /// </summary>
    public static Arm64RegisterX X4 => Arm64RegisterX.X4;
    /// <summary>
    /// Gets the X5 register.
    /// </summary>
    public static Arm64RegisterX X5 => Arm64RegisterX.X5;
    /// <summary>
    /// Gets the X6 register.
    /// </summary>
    public static Arm64RegisterX X6 => Arm64RegisterX.X6;
    /// <summary>
    /// Gets the X7 register.
    /// </summary>
    public static Arm64RegisterX X7 => Arm64RegisterX.X7;
    /// <summary>
    /// Gets the X8 register.
    /// </summary>
    public static Arm64RegisterX X8 => Arm64RegisterX.X8;
    /// <summary>
    /// Gets the X9 register.
    /// </summary>
    public static Arm64RegisterX X9 => Arm64RegisterX.X9;
    /// <summary>
    /// Gets the X10 register.
    /// </summary>
    public static Arm64RegisterX X10 => Arm64RegisterX.X10;
    /// <summary>
    /// Gets the X11 register.
    /// </summary>
    public static Arm64RegisterX X11 => Arm64RegisterX.X11;
    /// <summary>
    /// Gets the X12 register.
    /// </summary>
    public static Arm64RegisterX X12 => Arm64RegisterX.X12;
    /// <summary>
    /// Gets the X13 register.
    /// </summary>
    public static Arm64RegisterX X13 => Arm64RegisterX.X13;
    /// <summary>
    /// Gets the X14 register.
    /// </summary>
    public static Arm64RegisterX X14 => Arm64RegisterX.X14;
    /// <summary>
    /// Gets the X15 register.
    /// </summary>
    public static Arm64RegisterX X15 => Arm64RegisterX.X15;
    /// <summary>
    /// Gets the X16 register.
    /// </summary>
    public static Arm64RegisterX X16 => Arm64RegisterX.X16;
    /// <summary>
    /// Gets the X17 register.
    /// </summary>
    public static Arm64RegisterX X17 => Arm64RegisterX.X17;
    /// <summary>
    /// Gets the X18 register.
    /// </summary>
    public static Arm64RegisterX X18 => Arm64RegisterX.X18;
    /// <summary>
    /// Gets the X19 register.
    /// </summary>
    public static Arm64RegisterX X19 => Arm64RegisterX.X19;
    /// <summary>
    /// Gets the X20 register.
    /// </summary>
    public static Arm64RegisterX X20 => Arm64RegisterX.X20;
    /// <summary>
    /// Gets the X21 register.
    /// </summary>
    public static Arm64RegisterX X21 => Arm64RegisterX.X21;
    /// <summary>
    /// Gets the X22 register.
    /// </summary>
    public static Arm64RegisterX X22 => Arm64RegisterX.X22;
    /// <summary>
    /// Gets the X23 register.
    /// </summary>
    public static Arm64RegisterX X23 => Arm64RegisterX.X23;
    /// <summary>
    /// Gets the X24 register.
    /// </summary>
    public static Arm64RegisterX X24 => Arm64RegisterX.X24;
    /// <summary>
    /// Gets the X25 register.
    /// </summary>
    public static Arm64RegisterX X25 => Arm64RegisterX.X25;
    /// <summary>
    /// Gets the X26 register.
    /// </summary>
    public static Arm64RegisterX X26 => Arm64RegisterX.X26;
    /// <summary>
    /// Gets the X27 register.
    /// </summary>
    public static Arm64RegisterX X27 => Arm64RegisterX.X27;
    /// <summary>
    /// Gets the X28 register.
    /// </summary>
    public static Arm64RegisterX X28 => Arm64RegisterX.X28;
    /// <summary>
    /// Gets the X29 register.
    /// </summary>
    public static Arm64RegisterX X29 => Arm64RegisterX.X29;
    /// <summary>
    /// Gets the X30 register.
    /// </summary>
    public static Arm64RegisterX X30 => Arm64RegisterX.X30;
    /// <summary>
    /// Gets the W0 register.
    /// </summary>
    public static Arm64RegisterW W0 => Arm64RegisterW.W0;
    /// <summary>
    /// Gets the W1 register.
    /// </summary>
    public static Arm64RegisterW W1 => Arm64RegisterW.W1;
    /// <summary>
    /// Gets the W2 register.
    /// </summary>
    public static Arm64RegisterW W2 => Arm64RegisterW.W2;
    /// <summary>
    /// Gets the W3 register.
    /// </summary>
    public static Arm64RegisterW W3 => Arm64RegisterW.W3;
    /// <summary>
    /// Gets the W4 register.
    /// </summary>
    public static Arm64RegisterW W4 => Arm64RegisterW.W4;
    /// <summary>
    /// Gets the W5 register.
    /// </summary>
    public static Arm64RegisterW W5 => Arm64RegisterW.W5;
    /// <summary>
    /// Gets the W6 register.
    /// </summary>
    public static Arm64RegisterW W6 => Arm64RegisterW.W6;
    /// <summary>
    /// Gets the W7 register.
    /// </summary>
    public static Arm64RegisterW W7 => Arm64RegisterW.W7;
    /// <summary>
    /// Gets the W8 register.
    /// </summary>
    public static Arm64RegisterW W8 => Arm64RegisterW.W8;
    /// <summary>
    /// Gets the W9 register.
    /// </summary>
    public static Arm64RegisterW W9 => Arm64RegisterW.W9;
    /// <summary>
    /// Gets the W10 register.
    /// </summary>
    public static Arm64RegisterW W10 => Arm64RegisterW.W10;
    /// <summary>
    /// Gets the W11 register.
    /// </summary>
    public static Arm64RegisterW W11 => Arm64RegisterW.W11;
    /// <summary>
    /// Gets the W12 register.
    /// </summary>
    public static Arm64RegisterW W12 => Arm64RegisterW.W12;
    /// <summary>
    /// Gets the W13 register.
    /// </summary>
    public static Arm64RegisterW W13 => Arm64RegisterW.W13;
    /// <summary>
    /// Gets the W14 register.
    /// </summary>
    public static Arm64RegisterW W14 => Arm64RegisterW.W14;
    /// <summary>
    /// Gets the W15 register.
    /// </summary>
    public static Arm64RegisterW W15 => Arm64RegisterW.W15;
    /// <summary>
    /// Gets the W16 register.
    /// </summary>
    public static Arm64RegisterW W16 => Arm64RegisterW.W16;
    /// <summary>
    /// Gets the W17 register.
    /// </summary>
    public static Arm64RegisterW W17 => Arm64RegisterW.W17;
    /// <summary>
    /// Gets the W18 register.
    /// </summary>
    public static Arm64RegisterW W18 => Arm64RegisterW.W18;
    /// <summary>
    /// Gets the W19 register.
    /// </summary>
    public static Arm64RegisterW W19 => Arm64RegisterW.W19;
    /// <summary>
    /// Gets the W20 register.
    /// </summary>
    public static Arm64RegisterW W20 => Arm64RegisterW.W20;
    /// <summary>
    /// Gets the W21 register.
    /// </summary>
    public static Arm64RegisterW W21 => Arm64RegisterW.W21;
    /// <summary>
    /// Gets the W22 register.
    /// </summary>
    public static Arm64RegisterW W22 => Arm64RegisterW.W22;
    /// <summary>
    /// Gets the W23 register.
    /// </summary>
    public static Arm64RegisterW W23 => Arm64RegisterW.W23;
    /// <summary>
    /// Gets the W24 register.
    /// </summary>
    public static Arm64RegisterW W24 => Arm64RegisterW.W24;
    /// <summary>
    /// Gets the W25 register.
    /// </summary>
    public static Arm64RegisterW W25 => Arm64RegisterW.W25;
    /// <summary>
    /// Gets the W26 register.
    /// </summary>
    public static Arm64RegisterW W26 => Arm64RegisterW.W26;
    /// <summary>
    /// Gets the W27 register.
    /// </summary>
    public static Arm64RegisterW W27 => Arm64RegisterW.W27;
    /// <summary>
    /// Gets the W28 register.
    /// </summary>
    public static Arm64RegisterW W28 => Arm64RegisterW.W28;
    /// <summary>
    /// Gets the W29 register.
    /// </summary>
    public static Arm64RegisterW W29 => Arm64RegisterW.W29;
    /// <summary>
    /// Gets the W30 register.
    /// </summary>
    public static Arm64RegisterW W30 => Arm64RegisterW.W30;
    /// <summary>
    /// Gets the C0 register.
    /// </summary>
    public static Arm64RegisterC C0 => Arm64RegisterC.C0;
    /// <summary>
    /// Gets the C1 register.
    /// </summary>
    public static Arm64RegisterC C1 => Arm64RegisterC.C1;
    /// <summary>
    /// Gets the C2 register.
    /// </summary>
    public static Arm64RegisterC C2 => Arm64RegisterC.C2;
    /// <summary>
    /// Gets the C3 register.
    /// </summary>
    public static Arm64RegisterC C3 => Arm64RegisterC.C3;
    /// <summary>
    /// Gets the C4 register.
    /// </summary>
    public static Arm64RegisterC C4 => Arm64RegisterC.C4;
    /// <summary>
    /// Gets the C5 register.
    /// </summary>
    public static Arm64RegisterC C5 => Arm64RegisterC.C5;
    /// <summary>
    /// Gets the C6 register.
    /// </summary>
    public static Arm64RegisterC C6 => Arm64RegisterC.C6;
    /// <summary>
    /// Gets the C7 register.
    /// </summary>
    public static Arm64RegisterC C7 => Arm64RegisterC.C7;
    /// <summary>
    /// Gets the C8 register.
    /// </summary>
    public static Arm64RegisterC C8 => Arm64RegisterC.C8;
    /// <summary>
    /// Gets the C9 register.
    /// </summary>
    public static Arm64RegisterC C9 => Arm64RegisterC.C9;
    /// <summary>
    /// Gets the C10 register.
    /// </summary>
    public static Arm64RegisterC C10 => Arm64RegisterC.C10;
    /// <summary>
    /// Gets the C11 register.
    /// </summary>
    public static Arm64RegisterC C11 => Arm64RegisterC.C11;
    /// <summary>
    /// Gets the C12 register.
    /// </summary>
    public static Arm64RegisterC C12 => Arm64RegisterC.C12;
    /// <summary>
    /// Gets the C13 register.
    /// </summary>
    public static Arm64RegisterC C13 => Arm64RegisterC.C13;
    /// <summary>
    /// Gets the C14 register.
    /// </summary>
    public static Arm64RegisterC C14 => Arm64RegisterC.C14;
    /// <summary>
    /// Gets the C15 register.
    /// </summary>
    public static Arm64RegisterC C15 => Arm64RegisterC.C15;
    /// <summary>
    /// Gets the SP register.
    /// </summary>
    public static Arm64RegisterSP SP =>  Arm64RegisterSP.SP;
    /// <summary>
    /// Gets the WSP register.
    /// </summary>
    public static Arm64RegisterWSP WSP =>  Arm64RegisterWSP.WSP;
    /// <summary>
    /// Gets the V0 register.
    /// </summary>
    public static Arm64RegisterV V0 => Arm64RegisterV.V0;
    /// <summary>
    /// Gets the V1 register.
    /// </summary>
    public static Arm64RegisterV V1 => Arm64RegisterV.V1;
    /// <summary>
    /// Gets the V2 register.
    /// </summary>
    public static Arm64RegisterV V2 => Arm64RegisterV.V2;
    /// <summary>
    /// Gets the V3 register.
    /// </summary>
    public static Arm64RegisterV V3 => Arm64RegisterV.V3;
    /// <summary>
    /// Gets the V4 register.
    /// </summary>
    public static Arm64RegisterV V4 => Arm64RegisterV.V4;
    /// <summary>
    /// Gets the V5 register.
    /// </summary>
    public static Arm64RegisterV V5 => Arm64RegisterV.V5;
    /// <summary>
    /// Gets the V6 register.
    /// </summary>
    public static Arm64RegisterV V6 => Arm64RegisterV.V6;
    /// <summary>
    /// Gets the V7 register.
    /// </summary>
    public static Arm64RegisterV V7 => Arm64RegisterV.V7;
    /// <summary>
    /// Gets the V8 register.
    /// </summary>
    public static Arm64RegisterV V8 => Arm64RegisterV.V8;
    /// <summary>
    /// Gets the V9 register.
    /// </summary>
    public static Arm64RegisterV V9 => Arm64RegisterV.V9;
    /// <summary>
    /// Gets the V10 register.
    /// </summary>
    public static Arm64RegisterV V10 => Arm64RegisterV.V10;
    /// <summary>
    /// Gets the V11 register.
    /// </summary>
    public static Arm64RegisterV V11 => Arm64RegisterV.V11;
    /// <summary>
    /// Gets the V12 register.
    /// </summary>
    public static Arm64RegisterV V12 => Arm64RegisterV.V12;
    /// <summary>
    /// Gets the V13 register.
    /// </summary>
    public static Arm64RegisterV V13 => Arm64RegisterV.V13;
    /// <summary>
    /// Gets the V14 register.
    /// </summary>
    public static Arm64RegisterV V14 => Arm64RegisterV.V14;
    /// <summary>
    /// Gets the V15 register.
    /// </summary>
    public static Arm64RegisterV V15 => Arm64RegisterV.V15;
    /// <summary>
    /// Gets the V16 register.
    /// </summary>
    public static Arm64RegisterV V16 => Arm64RegisterV.V16;
    /// <summary>
    /// Gets the V17 register.
    /// </summary>
    public static Arm64RegisterV V17 => Arm64RegisterV.V17;
    /// <summary>
    /// Gets the V18 register.
    /// </summary>
    public static Arm64RegisterV V18 => Arm64RegisterV.V18;
    /// <summary>
    /// Gets the V19 register.
    /// </summary>
    public static Arm64RegisterV V19 => Arm64RegisterV.V19;
    /// <summary>
    /// Gets the V20 register.
    /// </summary>
    public static Arm64RegisterV V20 => Arm64RegisterV.V20;
    /// <summary>
    /// Gets the V21 register.
    /// </summary>
    public static Arm64RegisterV V21 => Arm64RegisterV.V21;
    /// <summary>
    /// Gets the V22 register.
    /// </summary>
    public static Arm64RegisterV V22 => Arm64RegisterV.V22;
    /// <summary>
    /// Gets the V23 register.
    /// </summary>
    public static Arm64RegisterV V23 => Arm64RegisterV.V23;
    /// <summary>
    /// Gets the V24 register.
    /// </summary>
    public static Arm64RegisterV V24 => Arm64RegisterV.V24;
    /// <summary>
    /// Gets the V25 register.
    /// </summary>
    public static Arm64RegisterV V25 => Arm64RegisterV.V25;
    /// <summary>
    /// Gets the V26 register.
    /// </summary>
    public static Arm64RegisterV V26 => Arm64RegisterV.V26;
    /// <summary>
    /// Gets the V27 register.
    /// </summary>
    public static Arm64RegisterV V27 => Arm64RegisterV.V27;
    /// <summary>
    /// Gets the V28 register.
    /// </summary>
    public static Arm64RegisterV V28 => Arm64RegisterV.V28;
    /// <summary>
    /// Gets the V29 register.
    /// </summary>
    public static Arm64RegisterV V29 => Arm64RegisterV.V29;
    /// <summary>
    /// Gets the V30 register.
    /// </summary>
    public static Arm64RegisterV V30 => Arm64RegisterV.V30;
    /// <summary>
    /// Gets the V31 register.
    /// </summary>
    public static Arm64RegisterV V31 => Arm64RegisterV.V31;

    /// <summary>
    /// Gets the H0 register.
    /// </summary>
    public static Arm64RegisterH H0 => Arm64RegisterH.H0;
    /// <summary>
    /// Gets the H1 register.
    /// </summary>
    public static Arm64RegisterH H1 => Arm64RegisterH.H1;
    /// <summary>
    /// Gets the H2 register.
    /// </summary>
    public static Arm64RegisterH H2 => Arm64RegisterH.H2;
    /// <summary>
    /// Gets the H3 register.
    /// </summary>
    public static Arm64RegisterH H3 => Arm64RegisterH.H3;
    /// <summary>
    /// Gets the H4 register.
    /// </summary>
    public static Arm64RegisterH H4 => Arm64RegisterH.H4;
    /// <summary>
    /// Gets the H5 register.
    /// </summary>
    public static Arm64RegisterH H5 => Arm64RegisterH.H5;
    /// <summary>
    /// Gets the H6 register.
    /// </summary>
    public static Arm64RegisterH H6 => Arm64RegisterH.H6;
    /// <summary>
    /// Gets the H7 register.
    /// </summary>
    public static Arm64RegisterH H7 => Arm64RegisterH.H7;
    /// <summary>
    /// Gets the H8 register.
    /// </summary>
    public static Arm64RegisterH H8 => Arm64RegisterH.H8;
    /// <summary>
    /// Gets the H9 register.
    /// </summary>
    public static Arm64RegisterH H9 => Arm64RegisterH.H9;
    /// <summary>
    /// Gets the H10 register.
    /// </summary>
    public static Arm64RegisterH H10 => Arm64RegisterH.H10;
    /// <summary>
    /// Gets the H11 register.
    /// </summary>
    public static Arm64RegisterH H11 => Arm64RegisterH.H11;
    /// <summary>
    /// Gets the H12 register.
    /// </summary>
    public static Arm64RegisterH H12 => Arm64RegisterH.H12;
    /// <summary>
    /// Gets the H13 register.
    /// </summary>
    public static Arm64RegisterH H13 => Arm64RegisterH.H13;
    /// <summary>
    /// Gets the H14 register.
    /// </summary>
    public static Arm64RegisterH H14 => Arm64RegisterH.H14;
    /// <summary>
    /// Gets the H15 register.
    /// </summary>
    public static Arm64RegisterH H15 => Arm64RegisterH.H15;
    /// <summary>
    /// Gets the H16 register.
    /// </summary>
    public static Arm64RegisterH H16 => Arm64RegisterH.H16;
    /// <summary>
    /// Gets the H17 register.
    /// </summary>
    public static Arm64RegisterH H17 => Arm64RegisterH.H17;
    /// <summary>
    /// Gets the H18 register.
    /// </summary>
    public static Arm64RegisterH H18 => Arm64RegisterH.H18;
    /// <summary>
    /// Gets the H19 register.
    /// </summary>
    public static Arm64RegisterH H19 => Arm64RegisterH.H19;
    /// <summary>
    /// Gets the H20 register.
    /// </summary>
    public static Arm64RegisterH H20 => Arm64RegisterH.H20;
    /// <summary>
    /// Gets the H21 register.
    /// </summary>
    public static Arm64RegisterH H21 => Arm64RegisterH.H21;
    /// <summary>
    /// Gets the H22 register.
    /// </summary>
    public static Arm64RegisterH H22 => Arm64RegisterH.H22;
    /// <summary>
    /// Gets the H23 register.
    /// </summary>
    public static Arm64RegisterH H23 => Arm64RegisterH.H23;
    /// <summary>
    /// Gets the H24 register.
    /// </summary>
    public static Arm64RegisterH H24 => Arm64RegisterH.H24;
    /// <summary>
    /// Gets the H25 register.
    /// </summary>
    public static Arm64RegisterH H25 => Arm64RegisterH.H25;
    /// <summary>
    /// Gets the H26 register.
    /// </summary>
    public static Arm64RegisterH H26 => Arm64RegisterH.H26;
    /// <summary>
    /// Gets the H27 register.
    /// </summary>
    public static Arm64RegisterH H27 => Arm64RegisterH.H27;
    /// <summary>
    /// Gets the H28 register.
    /// </summary>
    public static Arm64RegisterH H28 => Arm64RegisterH.H28;
    /// <summary>
    /// Gets the H29 register.
    /// </summary>
    public static Arm64RegisterH H29 => Arm64RegisterH.H29;
    /// <summary>
    /// Gets the H30 register.
    /// </summary>
    public static Arm64RegisterH H30 => Arm64RegisterH.H30;
    /// <summary>
    /// Gets the H31 register.
    /// </summary>
    public static Arm64RegisterH H31 => Arm64RegisterH.H31;
    /// <summary>
    /// Gets the S0 register.
    /// </summary>
    public static Arm64RegisterS S0 => Arm64RegisterS.S0;
    /// <summary>
    /// Gets the S1 register.
    /// </summary>
    public static Arm64RegisterS S1 => Arm64RegisterS.S1;
    /// <summary>
    /// Gets the S2 register.
    /// </summary>
    public static Arm64RegisterS S2 => Arm64RegisterS.S2;
    /// <summary>
    /// Gets the S3 register.
    /// </summary>
    public static Arm64RegisterS S3 => Arm64RegisterS.S3;
    /// <summary>
    /// Gets the S4 register.
    /// </summary>
    public static Arm64RegisterS S4 => Arm64RegisterS.S4;
    /// <summary>
    /// Gets the S5 register.
    /// </summary>
    public static Arm64RegisterS S5 => Arm64RegisterS.S5;
    /// <summary>
    /// Gets the S6 register.
    /// </summary>
    public static Arm64RegisterS S6 => Arm64RegisterS.S6;
    /// <summary>
    /// Gets the S7 register.
    /// </summary>
    public static Arm64RegisterS S7 => Arm64RegisterS.S7;
    /// <summary>
    /// Gets the S8 register.
    /// </summary>
    public static Arm64RegisterS S8 => Arm64RegisterS.S8;
    /// <summary>
    /// Gets the S9 register.
    /// </summary>
    public static Arm64RegisterS S9 => Arm64RegisterS.S9;
    /// <summary>
    /// Gets the S10 register.
    /// </summary>
    public static Arm64RegisterS S10 => Arm64RegisterS.S10;
    /// <summary>
    /// Gets the S11 register.
    /// </summary>
    public static Arm64RegisterS S11 => Arm64RegisterS.S11;
    /// <summary>
    /// Gets the S12 register.
    /// </summary>
    public static Arm64RegisterS S12 => Arm64RegisterS.S12;
    /// <summary>
    /// Gets the S13 register.
    /// </summary>
    public static Arm64RegisterS S13 => Arm64RegisterS.S13;
    /// <summary>
    /// Gets the S14 register.
    /// </summary>
    public static Arm64RegisterS S14 => Arm64RegisterS.S14;
    /// <summary>
    /// Gets the S15 register.
    /// </summary>
    public static Arm64RegisterS S15 => Arm64RegisterS.S15;
    /// <summary>
    /// Gets the S16 register.
    /// </summary>
    public static Arm64RegisterS S16 => Arm64RegisterS.S16;
    /// <summary>
    /// Gets the S17 register.
    /// </summary>
    public static Arm64RegisterS S17 => Arm64RegisterS.S17;
    /// <summary>
    /// Gets the S18 register.
    /// </summary>
    public static Arm64RegisterS S18 => Arm64RegisterS.S18;
    /// <summary>
    /// Gets the S19 register.
    /// </summary>
    public static Arm64RegisterS S19 => Arm64RegisterS.S19;
    /// <summary>
    /// Gets the S20 register.
    /// </summary>
    public static Arm64RegisterS S20 => Arm64RegisterS.S20;
    /// <summary>
    /// Gets the S21 register.
    /// </summary>
    public static Arm64RegisterS S21 => Arm64RegisterS.S21;
    /// <summary>
    /// Gets the S22 register.
    /// </summary>
    public static Arm64RegisterS S22 => Arm64RegisterS.S22;
    /// <summary>
    /// Gets the S23 register.
    /// </summary>
    public static Arm64RegisterS S23 => Arm64RegisterS.S23;
    /// <summary>
    /// Gets the S24 register.
    /// </summary>
    public static Arm64RegisterS S24 => Arm64RegisterS.S24;
    /// <summary>
    /// Gets the S25 register.
    /// </summary>
    public static Arm64RegisterS S25 => Arm64RegisterS.S25;
    /// <summary>
    /// Gets the S26 register.
    /// </summary>
    public static Arm64RegisterS S26 => Arm64RegisterS.S26;
    /// <summary>
    /// Gets the S27 register.
    /// </summary>
    public static Arm64RegisterS S27 => Arm64RegisterS.S27;
    /// <summary>
    /// Gets the S28 register.
    /// </summary>
    public static Arm64RegisterS S28 => Arm64RegisterS.S28;
    /// <summary>
    /// Gets the S29 register.
    /// </summary>
    public static Arm64RegisterS S29 => Arm64RegisterS.S29;
    /// <summary>
    /// Gets the S30 register.
    /// </summary>
    public static Arm64RegisterS S30 => Arm64RegisterS.S30;
    /// <summary>
    /// Gets the S31 register.
    /// </summary>
    public static Arm64RegisterS S31 => Arm64RegisterS.S31;
    /// <summary>
    /// Gets the D0 register.
    /// </summary>
    public static Arm64RegisterD D0 => Arm64RegisterD.D0;
    /// <summary>
    /// Gets the D1 register.
    /// </summary>
    public static Arm64RegisterD D1 => Arm64RegisterD.D1;
    /// <summary>
    /// Gets the D2 register.
    /// </summary>
    public static Arm64RegisterD D2 => Arm64RegisterD.D2;
    /// <summary>
    /// Gets the D3 register.
    /// </summary>
    public static Arm64RegisterD D3 => Arm64RegisterD.D3;
    /// <summary>
    /// Gets the D4 register.
    /// </summary>
    public static Arm64RegisterD D4 => Arm64RegisterD.D4;
    /// <summary>
    /// Gets the D5 register.
    /// </summary>
    public static Arm64RegisterD D5 => Arm64RegisterD.D5;
    /// <summary>
    /// Gets the D6 register.
    /// </summary>
    public static Arm64RegisterD D6 => Arm64RegisterD.D6;
    /// <summary>
    /// Gets the D7 register.
    /// </summary>
    public static Arm64RegisterD D7 => Arm64RegisterD.D7;
    /// <summary>
    /// Gets the D8 register.
    /// </summary>
    public static Arm64RegisterD D8 => Arm64RegisterD.D8;
    /// <summary>
    /// Gets the D9 register.
    /// </summary>
    public static Arm64RegisterD D9 => Arm64RegisterD.D9;
    /// <summary>
    /// Gets the D10 register.
    /// </summary>
    public static Arm64RegisterD D10 => Arm64RegisterD.D10;
    /// <summary>
    /// Gets the D11 register.
    /// </summary>
    public static Arm64RegisterD D11 => Arm64RegisterD.D11;
    /// <summary>
    /// Gets the D12 register.
    /// </summary>
    public static Arm64RegisterD D12 => Arm64RegisterD.D12;
    /// <summary>
    /// Gets the D13 register.
    /// </summary>
    public static Arm64RegisterD D13 => Arm64RegisterD.D13;
    /// <summary>
    /// Gets the D14 register.
    /// </summary>
    public static Arm64RegisterD D14 => Arm64RegisterD.D14;
    /// <summary>
    /// Gets the D15 register.
    /// </summary>
    public static Arm64RegisterD D15 => Arm64RegisterD.D15;
    /// <summary>
    /// Gets the D16 register.
    /// </summary>
    public static Arm64RegisterD D16 => Arm64RegisterD.D16;
    /// <summary>
    /// Gets the D17 register.
    /// </summary>
    public static Arm64RegisterD D17 => Arm64RegisterD.D17;
    /// <summary>
    /// Gets the D18 register.
    /// </summary>
    public static Arm64RegisterD D18 => Arm64RegisterD.D18;
    /// <summary>
    /// Gets the D19 register.
    /// </summary>
    public static Arm64RegisterD D19 => Arm64RegisterD.D19;
    /// <summary>
    /// Gets the D20 register.
    /// </summary>
    public static Arm64RegisterD D20 => Arm64RegisterD.D20;
    /// <summary>
    /// Gets the D21 register.
    /// </summary>
    public static Arm64RegisterD D21 => Arm64RegisterD.D21;
    /// <summary>
    /// Gets the D22 register.
    /// </summary>
    public static Arm64RegisterD D22 => Arm64RegisterD.D22;
    /// <summary>
    /// Gets the D23 register.
    /// </summary>
    public static Arm64RegisterD D23 => Arm64RegisterD.D23;
    /// <summary>
    /// Gets the D24 register.
    /// </summary>
    public static Arm64RegisterD D24 => Arm64RegisterD.D24;
    /// <summary>
    /// Gets the D25 register.
    /// </summary>
    public static Arm64RegisterD D25 => Arm64RegisterD.D25;
    /// <summary>
    /// Gets the D26 register.
    /// </summary>
    public static Arm64RegisterD D26 => Arm64RegisterD.D26;
    /// <summary>
    /// Gets the D27 register.
    /// </summary>
    public static Arm64RegisterD D27 => Arm64RegisterD.D27;
    /// <summary>
    /// Gets the D28 register.
    /// </summary>
    public static Arm64RegisterD D28 => Arm64RegisterD.D28;
    /// <summary>
    /// Gets the D29 register.
    /// </summary>
    public static Arm64RegisterD D29 => Arm64RegisterD.D29;
    /// <summary>
    /// Gets the D30 register.
    /// </summary>
    public static Arm64RegisterD D30 => Arm64RegisterD.D30;
    /// <summary>
    /// Gets the D31 register.
    /// </summary>
    public static Arm64RegisterD D31 => Arm64RegisterD.D31;
    /// <summary>
    /// Gets the Q0 register.
    /// </summary>
    public static Arm64RegisterQ Q0 => Arm64RegisterQ.Q0;
    /// <summary>
    /// Gets the Q1 register.
    /// </summary>
    public static Arm64RegisterQ Q1 => Arm64RegisterQ.Q1;
    /// <summary>
    /// Gets the Q2 register.
    /// </summary>
    public static Arm64RegisterQ Q2 => Arm64RegisterQ.Q2;
    /// <summary>
    /// Gets the Q3 register.
    /// </summary>
    public static Arm64RegisterQ Q3 => Arm64RegisterQ.Q3;
    /// <summary>
    /// Gets the Q4 register.
    /// </summary>
    public static Arm64RegisterQ Q4 => Arm64RegisterQ.Q4;
    /// <summary>
    /// Gets the Q5 register.
    /// </summary>
    public static Arm64RegisterQ Q5 => Arm64RegisterQ.Q5;
    /// <summary>
    /// Gets the Q6 register.
    /// </summary>
    public static Arm64RegisterQ Q6 => Arm64RegisterQ.Q6;
    /// <summary>
    /// Gets the Q7 register.
    /// </summary>
    public static Arm64RegisterQ Q7 => Arm64RegisterQ.Q7;
    /// <summary>
    /// Gets the Q8 register.
    /// </summary>
    public static Arm64RegisterQ Q8 => Arm64RegisterQ.Q8;
    /// <summary>
    /// Gets the Q9 register.
    /// </summary>
    public static Arm64RegisterQ Q9 => Arm64RegisterQ.Q9;
    /// <summary>
    /// Gets the Q10 register.
    /// </summary>
    public static Arm64RegisterQ Q10 => Arm64RegisterQ.Q10;
    /// <summary>
    /// Gets the Q11 register.
    /// </summary>
    public static Arm64RegisterQ Q11 => Arm64RegisterQ.Q11;
    /// <summary>
    /// Gets the Q12 register.
    /// </summary>
    public static Arm64RegisterQ Q12 => Arm64RegisterQ.Q12;
    /// <summary>
    /// Gets the Q13 register.
    /// </summary>
    public static Arm64RegisterQ Q13 => Arm64RegisterQ.Q13;
    /// <summary>
    /// Gets the Q14 register.
    /// </summary>
    public static Arm64RegisterQ Q14 => Arm64RegisterQ.Q14;
    /// <summary>
    /// Gets the Q15 register.
    /// </summary>
    public static Arm64RegisterQ Q15 => Arm64RegisterQ.Q15;
    /// <summary>
    /// Gets the Q16 register.
    /// </summary>
    public static Arm64RegisterQ Q16 => Arm64RegisterQ.Q16;
    /// <summary>
    /// Gets the Q17 register.
    /// </summary>
    public static Arm64RegisterQ Q17 => Arm64RegisterQ.Q17;
    /// <summary>
    /// Gets the Q18 register.
    /// </summary>
    public static Arm64RegisterQ Q18 => Arm64RegisterQ.Q18;
    /// <summary>
    /// Gets the Q19 register.
    /// </summary>
    public static Arm64RegisterQ Q19 => Arm64RegisterQ.Q19;
    /// <summary>
    /// Gets the Q20 register.
    /// </summary>
    public static Arm64RegisterQ Q20 => Arm64RegisterQ.Q20;
    /// <summary>
    /// Gets the Q21 register.
    /// </summary>
    public static Arm64RegisterQ Q21 => Arm64RegisterQ.Q21;
    /// <summary>
    /// Gets the Q22 register.
    /// </summary>
    public static Arm64RegisterQ Q22 => Arm64RegisterQ.Q22;
    /// <summary>
    /// Gets the Q23 register.
    /// </summary>
    public static Arm64RegisterQ Q23 => Arm64RegisterQ.Q23;
    /// <summary>
    /// Gets the Q24 register.
    /// </summary>
    public static Arm64RegisterQ Q24 => Arm64RegisterQ.Q24;
    /// <summary>
    /// Gets the Q25 register.
    /// </summary>
    public static Arm64RegisterQ Q25 => Arm64RegisterQ.Q25;
    /// <summary>
    /// Gets the Q26 register.
    /// </summary>
    public static Arm64RegisterQ Q26 => Arm64RegisterQ.Q26;
    /// <summary>
    /// Gets the Q27 register.
    /// </summary>
    public static Arm64RegisterQ Q27 => Arm64RegisterQ.Q27;
    /// <summary>
    /// Gets the Q28 register.
    /// </summary>
    public static Arm64RegisterQ Q28 => Arm64RegisterQ.Q28;
    /// <summary>
    /// Gets the Q29 register.
    /// </summary>
    public static Arm64RegisterQ Q29 => Arm64RegisterQ.Q29;
    /// <summary>
    /// Gets the Q30 register.
    /// </summary>
    public static Arm64RegisterQ Q30 => Arm64RegisterQ.Q30;
    /// <summary>
    /// Gets the Q31 register.
    /// </summary>
    public static Arm64RegisterQ Q31 => Arm64RegisterQ.Q31;
}

partial class Arm64Extensions
{
    /// <summary>
    /// Converts the X register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterX register, bool upperCase = false) => upperCase ? RegisterXUpperNames[ValidateRegisterIndex(register.Index)] : RegisterXLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterXLowerNames = [
        "x0",
        "x1",
        "x2",
        "x3",
        "x4",
        "x5",
        "x6",
        "x7",
        "x8",
        "x9",
        "x10",
        "x11",
        "x12",
        "x13",
        "x14",
        "x15",
        "x16",
        "x17",
        "x18",
        "x19",
        "x20",
        "x21",
        "x22",
        "x23",
        "x24",
        "x25",
        "x26",
        "x27",
        "x28",
        "x29",
        "x30",
        "xzr",
    ];

    private static readonly string[] RegisterXUpperNames = [
        "X0",
        "X1",
        "X2",
        "X3",
        "X4",
        "X5",
        "X6",
        "X7",
        "X8",
        "X9",
        "X10",
        "X11",
        "X12",
        "X13",
        "X14",
        "X15",
        "X16",
        "X17",
        "X18",
        "X19",
        "X20",
        "X21",
        "X22",
        "X23",
        "X24",
        "X25",
        "X26",
        "X27",
        "X28",
        "X29",
        "X30",
        "XZR",
    ];
    /// <summary>
    /// Converts the W register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterW register, bool upperCase = false) => upperCase ? RegisterWUpperNames[ValidateRegisterIndex(register.Index)] : RegisterWLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterWLowerNames = [
        "w0",
        "w1",
        "w2",
        "w3",
        "w4",
        "w5",
        "w6",
        "w7",
        "w8",
        "w9",
        "w10",
        "w11",
        "w12",
        "w13",
        "w14",
        "w15",
        "w16",
        "w17",
        "w18",
        "w19",
        "w20",
        "w21",
        "w22",
        "w23",
        "w24",
        "w25",
        "w26",
        "w27",
        "w28",
        "w29",
        "w30",
        "wzr",
    ];

    private static readonly string[] RegisterWUpperNames = [
        "W0",
        "W1",
        "W2",
        "W3",
        "W4",
        "W5",
        "W6",
        "W7",
        "W8",
        "W9",
        "W10",
        "W11",
        "W12",
        "W13",
        "W14",
        "W15",
        "W16",
        "W17",
        "W18",
        "W19",
        "W20",
        "W21",
        "W22",
        "W23",
        "W24",
        "W25",
        "W26",
        "W27",
        "W28",
        "W29",
        "W30",
        "WZR",
    ];
    /// <summary>
    /// Converts the C register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterC register, bool upperCase = false) => upperCase ? RegisterCUpperNames[ValidateRegisterIndex(register.Index)] : RegisterCLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterCLowerNames = [
        "c0",
        "c1",
        "c2",
        "c3",
        "c4",
        "c5",
        "c6",
        "c7",
        "c8",
        "c9",
        "c10",
        "c11",
        "c12",
        "c13",
        "c14",
        "c15",
    ];

    private static readonly string[] RegisterCUpperNames = [
        "C0",
        "C1",
        "C2",
        "C3",
        "C4",
        "C5",
        "C6",
        "C7",
        "C8",
        "C9",
        "C10",
        "C11",
        "C12",
        "C13",
        "C14",
        "C15",
    ];
    /// <summary>
    /// Converts the SP register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterSP register, bool upperCase = false) => upperCase ? RegisterSPUpperNames[ValidateRegisterIndex(register.Index)] : RegisterSPLowerNames[ValidateRegisterIndex(register.Index)];
    private static readonly string[] RegisterSPLowerNames = [
        "??", // 0
        "??", // 1
        "??", // 2
        "??", // 3
        "??", // 4
        "??", // 5
        "??", // 6
        "??", // 7
        "??", // 8
        "??", // 9
        "??", // 10
        "??", // 11
        "??", // 12
        "??", // 13
        "??", // 14
        "??", // 15
        "??", // 16
        "??", // 17
        "??", // 18
        "??", // 19
        "??", // 20
        "??", // 21
        "??", // 22
        "??", // 23
        "??", // 24
        "??", // 25
        "??", // 26
        "??", // 27
        "??", // 28
        "??", // 29
        "??", // 30
        "sp", // 31
    ];

    private static readonly string[] RegisterSPUpperNames = [
        "??", // 0
        "??", // 1
        "??", // 2
        "??", // 3
        "??", // 4
        "??", // 5
        "??", // 6
        "??", // 7
        "??", // 8
        "??", // 9
        "??", // 10
        "??", // 11
        "??", // 12
        "??", // 13
        "??", // 14
        "??", // 15
        "??", // 16
        "??", // 17
        "??", // 18
        "??", // 19
        "??", // 20
        "??", // 21
        "??", // 22
        "??", // 23
        "??", // 24
        "??", // 25
        "??", // 26
        "??", // 27
        "??", // 28
        "??", // 29
        "??", // 30
        "SP", // 31
    ];
    /// <summary>
    /// Converts the WSP register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterWSP register, bool upperCase = false) => upperCase ? RegisterWSPUpperNames[ValidateRegisterIndex(register.Index)] : RegisterWSPLowerNames[ValidateRegisterIndex(register.Index)];
    private static readonly string[] RegisterWSPLowerNames = [
        "??", // 0
        "??", // 1
        "??", // 2
        "??", // 3
        "??", // 4
        "??", // 5
        "??", // 6
        "??", // 7
        "??", // 8
        "??", // 9
        "??", // 10
        "??", // 11
        "??", // 12
        "??", // 13
        "??", // 14
        "??", // 15
        "??", // 16
        "??", // 17
        "??", // 18
        "??", // 19
        "??", // 20
        "??", // 21
        "??", // 22
        "??", // 23
        "??", // 24
        "??", // 25
        "??", // 26
        "??", // 27
        "??", // 28
        "??", // 29
        "??", // 30
        "wsp", // 31
    ];

    private static readonly string[] RegisterWSPUpperNames = [
        "??", // 0
        "??", // 1
        "??", // 2
        "??", // 3
        "??", // 4
        "??", // 5
        "??", // 6
        "??", // 7
        "??", // 8
        "??", // 9
        "??", // 10
        "??", // 11
        "??", // 12
        "??", // 13
        "??", // 14
        "??", // 15
        "??", // 16
        "??", // 17
        "??", // 18
        "??", // 19
        "??", // 20
        "??", // 21
        "??", // 22
        "??", // 23
        "??", // 24
        "??", // 25
        "??", // 26
        "??", // 27
        "??", // 28
        "??", // 29
        "??", // 30
        "WSP", // 31
    ];
    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV register, bool upperCase = false) => upperCase ? RegisterVUpperNames[ValidateRegisterIndex(register.Index)] : RegisterVLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterVLowerNames = [
        "v0",
        "v1",
        "v2",
        "v3",
        "v4",
        "v5",
        "v6",
        "v7",
        "v8",
        "v9",
        "v10",
        "v11",
        "v12",
        "v13",
        "v14",
        "v15",
        "v16",
        "v17",
        "v18",
        "v19",
        "v20",
        "v21",
        "v22",
        "v23",
        "v24",
        "v25",
        "v26",
        "v27",
        "v28",
        "v29",
        "v30",
        "v31",
    ];

    private static readonly string[] RegisterVUpperNames = [
        "V0",
        "V1",
        "V2",
        "V3",
        "V4",
        "V5",
        "V6",
        "V7",
        "V8",
        "V9",
        "V10",
        "V11",
        "V12",
        "V13",
        "V14",
        "V15",
        "V16",
        "V17",
        "V18",
        "V19",
        "V20",
        "V21",
        "V22",
        "V23",
        "V24",
        "V25",
        "V26",
        "V27",
        "V28",
        "V29",
        "V30",
        "V31",
    ];
    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterB register, bool upperCase = false) => upperCase ? RegisterVScalarBUpperNames[ValidateRegisterIndex(register.Index)] : RegisterVScalarBLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterVScalarBLowerNames = [
        "b0",
        "b1",
        "b2",
        "b3",
        "b4",
        "b5",
        "b6",
        "b7",
        "b8",
        "b9",
        "b10",
        "b11",
        "b12",
        "b13",
        "b14",
        "b15",
        "b16",
        "b17",
        "b18",
        "b19",
        "b20",
        "b21",
        "b22",
        "b23",
        "b24",
        "b25",
        "b26",
        "b27",
        "b28",
        "b29",
        "b30",
        "b31",
        ];

    private static readonly string[] RegisterVScalarBUpperNames = [
        "B0",
        "B1",
        "B2",
        "B3",
        "B4",
        "B5",
        "B6",
        "B7",
        "B8",
        "B9",
        "B10",
        "B11",
        "B12",
        "B13",
        "B14",
        "B15",
        "B16",
        "B17",
        "B18",
        "B19",
        "B20",
        "B21",
        "B22",
        "B23",
        "B24",
        "B25",
        "B26",
        "B27",
        "B28",
        "B29",
        "B30",
        "B31",
        ];

    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_B register, bool upperCase = false) => upperCase ? RegisterV_BUpperNames[ValidateRegisterIndex(register.Index)] : RegisterV_BLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV_BLowerNames = [
        "v0.b",
        "v1.b",
        "v2.b",
        "v3.b",
        "v4.b",
        "v5.b",
        "v6.b",
        "v7.b",
        "v8.b",
        "v9.b",
        "v10.b",
        "v11.b",
        "v12.b",
        "v13.b",
        "v14.b",
        "v15.b",
        "v16.b",
        "v17.b",
        "v18.b",
        "v19.b",
        "v20.b",
        "v21.b",
        "v22.b",
        "v23.b",
        "v24.b",
        "v25.b",
        "v26.b",
        "v27.b",
        "v28.b",
        "v29.b",
        "v30.b",
        "v31.b",
        ];

    private static readonly string[] RegisterV_BUpperNames = [
        "V0.B",
        "V1.B",
        "V2.B",
        "V3.B",
        "V4.B",
        "V5.B",
        "V6.B",
        "V7.B",
        "V8.B",
        "V9.B",
        "V10.B",
        "V11.B",
        "V12.B",
        "V13.B",
        "V14.B",
        "V15.B",
        "V16.B",
        "V17.B",
        "V18.B",
        "V19.B",
        "V20.B",
        "V21.B",
        "V22.B",
        "V23.B",
        "V24.B",
        "V25.B",
        "V26.B",
        "V27.B",
        "V28.B",
        "V29.B",
        "V30.B",
        "V31.B",
        ];


    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_2B register, bool upperCase = false) => upperCase ? RegisterV2BUpperNames[ValidateRegisterIndex(register.Index)] : RegisterV2BLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV2BLowerNames = [
        "v0.2b",
        "v1.2b",
        "v2.2b",
        "v3.2b",
        "v4.2b",
        "v5.2b",
        "v6.2b",
        "v7.2b",
        "v8.2b",
        "v9.2b",
        "v10.2b",
        "v11.2b",
        "v12.2b",
        "v13.2b",
        "v14.2b",
        "v15.2b",
        "v16.2b",
        "v17.2b",
        "v18.2b",
        "v19.2b",
        "v20.2b",
        "v21.2b",
        "v22.2b",
        "v23.2b",
        "v24.2b",
        "v25.2b",
        "v26.2b",
        "v27.2b",
        "v28.2b",
        "v29.2b",
        "v30.2b",
        "v31.2b",
        ];

    private static readonly string[] RegisterV2BUpperNames = [
        "V0.2B",
        "V1.2B",
        "V2.2B",
        "V3.2B",
        "V4.2B",
        "V5.2B",
        "V6.2B",
        "V7.2B",
        "V8.2B",
        "V9.2B",
        "V10.2B",
        "V11.2B",
        "V12.2B",
        "V13.2B",
        "V14.2B",
        "V15.2B",
        "V16.2B",
        "V17.2B",
        "V18.2B",
        "V19.2B",
        "V20.2B",
        "V21.2B",
        "V22.2B",
        "V23.2B",
        "V24.2B",
        "V25.2B",
        "V26.2B",
        "V27.2B",
        "V28.2B",
        "V29.2B",
        "V30.2B",
        "V31.2B",
        ];

    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_4B register, bool upperCase = false) => upperCase ? RegisterV4BUpperNames[ValidateRegisterIndex(register.Index)] : RegisterV4BLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV4BLowerNames = [
        "v0.4b",
        "v1.4b",
        "v2.4b",
        "v3.4b",
        "v4.4b",
        "v5.4b",
        "v6.4b",
        "v7.4b",
        "v8.4b",
        "v9.4b",
        "v10.4b",
        "v11.4b",
        "v12.4b",
        "v13.4b",
        "v14.4b",
        "v15.4b",
        "v16.4b",
        "v17.4b",
        "v18.4b",
        "v19.4b",
        "v20.4b",
        "v21.4b",
        "v22.4b",
        "v23.4b",
        "v24.4b",
        "v25.4b",
        "v26.4b",
        "v27.4b",
        "v28.4b",
        "v29.4b",
        "v30.4b",
        "v31.4b",
        ];

    private static readonly string[] RegisterV4BUpperNames = [
        "V0.4B",
        "V1.4B",
        "V2.4B",
        "V3.4B",
        "V4.4B",
        "V5.4B",
        "V6.4B",
        "V7.4B",
        "V8.4B",
        "V9.4B",
        "V10.4B",
        "V11.4B",
        "V12.4B",
        "V13.4B",
        "V14.4B",
        "V15.4B",
        "V16.4B",
        "V17.4B",
        "V18.4B",
        "V19.4B",
        "V20.4B",
        "V21.4B",
        "V22.4B",
        "V23.4B",
        "V24.4B",
        "V25.4B",
        "V26.4B",
        "V27.4B",
        "V28.4B",
        "V29.4B",
        "V30.4B",
        "V31.4B",
        ];

    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_8B register, bool upperCase = false) => upperCase ? RegisterV8BUpperNames[ValidateRegisterIndex(register.Index)] : RegisterV8BLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV8BLowerNames = [
        "v0.8b",
        "v1.8b",
        "v2.8b",
        "v3.8b",
        "v4.8b",
        "v5.8b",
        "v6.8b",
        "v7.8b",
        "v8.8b",
        "v9.8b",
        "v10.8b",
        "v11.8b",
        "v12.8b",
        "v13.8b",
        "v14.8b",
        "v15.8b",
        "v16.8b",
        "v17.8b",
        "v18.8b",
        "v19.8b",
        "v20.8b",
        "v21.8b",
        "v22.8b",
        "v23.8b",
        "v24.8b",
        "v25.8b",
        "v26.8b",
        "v27.8b",
        "v28.8b",
        "v29.8b",
        "v30.8b",
        "v31.8b",
        ];

    private static readonly string[] RegisterV8BUpperNames = [
        "V0.8B",
        "V1.8B",
        "V2.8B",
        "V3.8B",
        "V4.8B",
        "V5.8B",
        "V6.8B",
        "V7.8B",
        "V8.8B",
        "V9.8B",
        "V10.8B",
        "V11.8B",
        "V12.8B",
        "V13.8B",
        "V14.8B",
        "V15.8B",
        "V16.8B",
        "V17.8B",
        "V18.8B",
        "V19.8B",
        "V20.8B",
        "V21.8B",
        "V22.8B",
        "V23.8B",
        "V24.8B",
        "V25.8B",
        "V26.8B",
        "V27.8B",
        "V28.8B",
        "V29.8B",
        "V30.8B",
        "V31.8B",
        ];

    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_16B register, bool upperCase = false) => upperCase ? RegisterV16BUpperNames[ValidateRegisterIndex(register.Index)] : RegisterV16BLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV16BLowerNames = [
        "v0.16b",
        "v1.16b",
        "v2.16b",
        "v3.16b",
        "v4.16b",
        "v5.16b",
        "v6.16b",
        "v7.16b",
        "v8.16b",
        "v9.16b",
        "v10.16b",
        "v11.16b",
        "v12.16b",
        "v13.16b",
        "v14.16b",
        "v15.16b",
        "v16.16b",
        "v17.16b",
        "v18.16b",
        "v19.16b",
        "v20.16b",
        "v21.16b",
        "v22.16b",
        "v23.16b",
        "v24.16b",
        "v25.16b",
        "v26.16b",
        "v27.16b",
        "v28.16b",
        "v29.16b",
        "v30.16b",
        "v31.16b",
        ];

    private static readonly string[] RegisterV16BUpperNames = [
        "V0.16B",
        "V1.16B",
        "V2.16B",
        "V3.16B",
        "V4.16B",
        "V5.16B",
        "V6.16B",
        "V7.16B",
        "V8.16B",
        "V9.16B",
        "V10.16B",
        "V11.16B",
        "V12.16B",
        "V13.16B",
        "V14.16B",
        "V15.16B",
        "V16.16B",
        "V17.16B",
        "V18.16B",
        "V19.16B",
        "V20.16B",
        "V21.16B",
        "V22.16B",
        "V23.16B",
        "V24.16B",
        "V25.16B",
        "V26.16B",
        "V27.16B",
        "V28.16B",
        "V29.16B",
        "V30.16B",
        "V31.16B",
        ];
    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterH register, bool upperCase = false) => upperCase ? RegisterVScalarHUpperNames[ValidateRegisterIndex(register.Index)] : RegisterVScalarHLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterVScalarHLowerNames = [
        "h0",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "h7",
        "h8",
        "h9",
        "h10",
        "h11",
        "h12",
        "h13",
        "h14",
        "h15",
        "h16",
        "h17",
        "h18",
        "h19",
        "h20",
        "h21",
        "h22",
        "h23",
        "h24",
        "h25",
        "h26",
        "h27",
        "h28",
        "h29",
        "h30",
        "h31",
        ];

    private static readonly string[] RegisterVScalarHUpperNames = [
        "H0",
        "H1",
        "H2",
        "H3",
        "H4",
        "H5",
        "H6",
        "H7",
        "H8",
        "H9",
        "H10",
        "H11",
        "H12",
        "H13",
        "H14",
        "H15",
        "H16",
        "H17",
        "H18",
        "H19",
        "H20",
        "H21",
        "H22",
        "H23",
        "H24",
        "H25",
        "H26",
        "H27",
        "H28",
        "H29",
        "H30",
        "H31",
        ];

    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_H register, bool upperCase = false) => upperCase ? RegisterV_HUpperNames[ValidateRegisterIndex(register.Index)] : RegisterV_HLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV_HLowerNames = [
        "v0.h",
        "v1.h",
        "v2.h",
        "v3.h",
        "v4.h",
        "v5.h",
        "v6.h",
        "v7.h",
        "v8.h",
        "v9.h",
        "v10.h",
        "v11.h",
        "v12.h",
        "v13.h",
        "v14.h",
        "v15.h",
        "v16.h",
        "v17.h",
        "v18.h",
        "v19.h",
        "v20.h",
        "v21.h",
        "v22.h",
        "v23.h",
        "v24.h",
        "v25.h",
        "v26.h",
        "v27.h",
        "v28.h",
        "v29.h",
        "v30.h",
        "v31.h",
        ];

    private static readonly string[] RegisterV_HUpperNames = [
        "V0.H",
        "V1.H",
        "V2.H",
        "V3.H",
        "V4.H",
        "V5.H",
        "V6.H",
        "V7.H",
        "V8.H",
        "V9.H",
        "V10.H",
        "V11.H",
        "V12.H",
        "V13.H",
        "V14.H",
        "V15.H",
        "V16.H",
        "V17.H",
        "V18.H",
        "V19.H",
        "V20.H",
        "V21.H",
        "V22.H",
        "V23.H",
        "V24.H",
        "V25.H",
        "V26.H",
        "V27.H",
        "V28.H",
        "V29.H",
        "V30.H",
        "V31.H",
        ];


    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_2H register, bool upperCase = false) => upperCase ? RegisterV2HUpperNames[ValidateRegisterIndex(register.Index)] : RegisterV2HLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV2HLowerNames = [
        "v0.2h",
        "v1.2h",
        "v2.2h",
        "v3.2h",
        "v4.2h",
        "v5.2h",
        "v6.2h",
        "v7.2h",
        "v8.2h",
        "v9.2h",
        "v10.2h",
        "v11.2h",
        "v12.2h",
        "v13.2h",
        "v14.2h",
        "v15.2h",
        "v16.2h",
        "v17.2h",
        "v18.2h",
        "v19.2h",
        "v20.2h",
        "v21.2h",
        "v22.2h",
        "v23.2h",
        "v24.2h",
        "v25.2h",
        "v26.2h",
        "v27.2h",
        "v28.2h",
        "v29.2h",
        "v30.2h",
        "v31.2h",
        ];

    private static readonly string[] RegisterV2HUpperNames = [
        "V0.2H",
        "V1.2H",
        "V2.2H",
        "V3.2H",
        "V4.2H",
        "V5.2H",
        "V6.2H",
        "V7.2H",
        "V8.2H",
        "V9.2H",
        "V10.2H",
        "V11.2H",
        "V12.2H",
        "V13.2H",
        "V14.2H",
        "V15.2H",
        "V16.2H",
        "V17.2H",
        "V18.2H",
        "V19.2H",
        "V20.2H",
        "V21.2H",
        "V22.2H",
        "V23.2H",
        "V24.2H",
        "V25.2H",
        "V26.2H",
        "V27.2H",
        "V28.2H",
        "V29.2H",
        "V30.2H",
        "V31.2H",
        ];

    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_4H register, bool upperCase = false) => upperCase ? RegisterV4HUpperNames[ValidateRegisterIndex(register.Index)] : RegisterV4HLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV4HLowerNames = [
        "v0.4h",
        "v1.4h",
        "v2.4h",
        "v3.4h",
        "v4.4h",
        "v5.4h",
        "v6.4h",
        "v7.4h",
        "v8.4h",
        "v9.4h",
        "v10.4h",
        "v11.4h",
        "v12.4h",
        "v13.4h",
        "v14.4h",
        "v15.4h",
        "v16.4h",
        "v17.4h",
        "v18.4h",
        "v19.4h",
        "v20.4h",
        "v21.4h",
        "v22.4h",
        "v23.4h",
        "v24.4h",
        "v25.4h",
        "v26.4h",
        "v27.4h",
        "v28.4h",
        "v29.4h",
        "v30.4h",
        "v31.4h",
        ];

    private static readonly string[] RegisterV4HUpperNames = [
        "V0.4H",
        "V1.4H",
        "V2.4H",
        "V3.4H",
        "V4.4H",
        "V5.4H",
        "V6.4H",
        "V7.4H",
        "V8.4H",
        "V9.4H",
        "V10.4H",
        "V11.4H",
        "V12.4H",
        "V13.4H",
        "V14.4H",
        "V15.4H",
        "V16.4H",
        "V17.4H",
        "V18.4H",
        "V19.4H",
        "V20.4H",
        "V21.4H",
        "V22.4H",
        "V23.4H",
        "V24.4H",
        "V25.4H",
        "V26.4H",
        "V27.4H",
        "V28.4H",
        "V29.4H",
        "V30.4H",
        "V31.4H",
        ];

    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_8H register, bool upperCase = false) => upperCase ? RegisterV8HUpperNames[ValidateRegisterIndex(register.Index)] : RegisterV8HLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV8HLowerNames = [
        "v0.8h",
        "v1.8h",
        "v2.8h",
        "v3.8h",
        "v4.8h",
        "v5.8h",
        "v6.8h",
        "v7.8h",
        "v8.8h",
        "v9.8h",
        "v10.8h",
        "v11.8h",
        "v12.8h",
        "v13.8h",
        "v14.8h",
        "v15.8h",
        "v16.8h",
        "v17.8h",
        "v18.8h",
        "v19.8h",
        "v20.8h",
        "v21.8h",
        "v22.8h",
        "v23.8h",
        "v24.8h",
        "v25.8h",
        "v26.8h",
        "v27.8h",
        "v28.8h",
        "v29.8h",
        "v30.8h",
        "v31.8h",
        ];

    private static readonly string[] RegisterV8HUpperNames = [
        "V0.8H",
        "V1.8H",
        "V2.8H",
        "V3.8H",
        "V4.8H",
        "V5.8H",
        "V6.8H",
        "V7.8H",
        "V8.8H",
        "V9.8H",
        "V10.8H",
        "V11.8H",
        "V12.8H",
        "V13.8H",
        "V14.8H",
        "V15.8H",
        "V16.8H",
        "V17.8H",
        "V18.8H",
        "V19.8H",
        "V20.8H",
        "V21.8H",
        "V22.8H",
        "V23.8H",
        "V24.8H",
        "V25.8H",
        "V26.8H",
        "V27.8H",
        "V28.8H",
        "V29.8H",
        "V30.8H",
        "V31.8H",
        ];
    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterS register, bool upperCase = false) => upperCase ? RegisterVScalarSUpperNames[ValidateRegisterIndex(register.Index)] : RegisterVScalarSLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterVScalarSLowerNames = [
        "s0",
        "s1",
        "s2",
        "s3",
        "s4",
        "s5",
        "s6",
        "s7",
        "s8",
        "s9",
        "s10",
        "s11",
        "s12",
        "s13",
        "s14",
        "s15",
        "s16",
        "s17",
        "s18",
        "s19",
        "s20",
        "s21",
        "s22",
        "s23",
        "s24",
        "s25",
        "s26",
        "s27",
        "s28",
        "s29",
        "s30",
        "s31",
        ];

    private static readonly string[] RegisterVScalarSUpperNames = [
        "S0",
        "S1",
        "S2",
        "S3",
        "S4",
        "S5",
        "S6",
        "S7",
        "S8",
        "S9",
        "S10",
        "S11",
        "S12",
        "S13",
        "S14",
        "S15",
        "S16",
        "S17",
        "S18",
        "S19",
        "S20",
        "S21",
        "S22",
        "S23",
        "S24",
        "S25",
        "S26",
        "S27",
        "S28",
        "S29",
        "S30",
        "S31",
        ];

    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_S register, bool upperCase = false) => upperCase ? RegisterV_SUpperNames[ValidateRegisterIndex(register.Index)] : RegisterV_SLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV_SLowerNames = [
        "v0.s",
        "v1.s",
        "v2.s",
        "v3.s",
        "v4.s",
        "v5.s",
        "v6.s",
        "v7.s",
        "v8.s",
        "v9.s",
        "v10.s",
        "v11.s",
        "v12.s",
        "v13.s",
        "v14.s",
        "v15.s",
        "v16.s",
        "v17.s",
        "v18.s",
        "v19.s",
        "v20.s",
        "v21.s",
        "v22.s",
        "v23.s",
        "v24.s",
        "v25.s",
        "v26.s",
        "v27.s",
        "v28.s",
        "v29.s",
        "v30.s",
        "v31.s",
        ];

    private static readonly string[] RegisterV_SUpperNames = [
        "V0.S",
        "V1.S",
        "V2.S",
        "V3.S",
        "V4.S",
        "V5.S",
        "V6.S",
        "V7.S",
        "V8.S",
        "V9.S",
        "V10.S",
        "V11.S",
        "V12.S",
        "V13.S",
        "V14.S",
        "V15.S",
        "V16.S",
        "V17.S",
        "V18.S",
        "V19.S",
        "V20.S",
        "V21.S",
        "V22.S",
        "V23.S",
        "V24.S",
        "V25.S",
        "V26.S",
        "V27.S",
        "V28.S",
        "V29.S",
        "V30.S",
        "V31.S",
        ];


    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_2S register, bool upperCase = false) => upperCase ? RegisterV2SUpperNames[ValidateRegisterIndex(register.Index)] : RegisterV2SLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV2SLowerNames = [
        "v0.2s",
        "v1.2s",
        "v2.2s",
        "v3.2s",
        "v4.2s",
        "v5.2s",
        "v6.2s",
        "v7.2s",
        "v8.2s",
        "v9.2s",
        "v10.2s",
        "v11.2s",
        "v12.2s",
        "v13.2s",
        "v14.2s",
        "v15.2s",
        "v16.2s",
        "v17.2s",
        "v18.2s",
        "v19.2s",
        "v20.2s",
        "v21.2s",
        "v22.2s",
        "v23.2s",
        "v24.2s",
        "v25.2s",
        "v26.2s",
        "v27.2s",
        "v28.2s",
        "v29.2s",
        "v30.2s",
        "v31.2s",
        ];

    private static readonly string[] RegisterV2SUpperNames = [
        "V0.2S",
        "V1.2S",
        "V2.2S",
        "V3.2S",
        "V4.2S",
        "V5.2S",
        "V6.2S",
        "V7.2S",
        "V8.2S",
        "V9.2S",
        "V10.2S",
        "V11.2S",
        "V12.2S",
        "V13.2S",
        "V14.2S",
        "V15.2S",
        "V16.2S",
        "V17.2S",
        "V18.2S",
        "V19.2S",
        "V20.2S",
        "V21.2S",
        "V22.2S",
        "V23.2S",
        "V24.2S",
        "V25.2S",
        "V26.2S",
        "V27.2S",
        "V28.2S",
        "V29.2S",
        "V30.2S",
        "V31.2S",
        ];

    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_4S register, bool upperCase = false) => upperCase ? RegisterV4SUpperNames[ValidateRegisterIndex(register.Index)] : RegisterV4SLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV4SLowerNames = [
        "v0.4s",
        "v1.4s",
        "v2.4s",
        "v3.4s",
        "v4.4s",
        "v5.4s",
        "v6.4s",
        "v7.4s",
        "v8.4s",
        "v9.4s",
        "v10.4s",
        "v11.4s",
        "v12.4s",
        "v13.4s",
        "v14.4s",
        "v15.4s",
        "v16.4s",
        "v17.4s",
        "v18.4s",
        "v19.4s",
        "v20.4s",
        "v21.4s",
        "v22.4s",
        "v23.4s",
        "v24.4s",
        "v25.4s",
        "v26.4s",
        "v27.4s",
        "v28.4s",
        "v29.4s",
        "v30.4s",
        "v31.4s",
        ];

    private static readonly string[] RegisterV4SUpperNames = [
        "V0.4S",
        "V1.4S",
        "V2.4S",
        "V3.4S",
        "V4.4S",
        "V5.4S",
        "V6.4S",
        "V7.4S",
        "V8.4S",
        "V9.4S",
        "V10.4S",
        "V11.4S",
        "V12.4S",
        "V13.4S",
        "V14.4S",
        "V15.4S",
        "V16.4S",
        "V17.4S",
        "V18.4S",
        "V19.4S",
        "V20.4S",
        "V21.4S",
        "V22.4S",
        "V23.4S",
        "V24.4S",
        "V25.4S",
        "V26.4S",
        "V27.4S",
        "V28.4S",
        "V29.4S",
        "V30.4S",
        "V31.4S",
        ];
    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterD register, bool upperCase = false) => upperCase ? RegisterVScalarDUpperNames[ValidateRegisterIndex(register.Index)] : RegisterVScalarDLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterVScalarDLowerNames = [
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5",
        "d6",
        "d7",
        "d8",
        "d9",
        "d10",
        "d11",
        "d12",
        "d13",
        "d14",
        "d15",
        "d16",
        "d17",
        "d18",
        "d19",
        "d20",
        "d21",
        "d22",
        "d23",
        "d24",
        "d25",
        "d26",
        "d27",
        "d28",
        "d29",
        "d30",
        "d31",
        ];

    private static readonly string[] RegisterVScalarDUpperNames = [
        "D0",
        "D1",
        "D2",
        "D3",
        "D4",
        "D5",
        "D6",
        "D7",
        "D8",
        "D9",
        "D10",
        "D11",
        "D12",
        "D13",
        "D14",
        "D15",
        "D16",
        "D17",
        "D18",
        "D19",
        "D20",
        "D21",
        "D22",
        "D23",
        "D24",
        "D25",
        "D26",
        "D27",
        "D28",
        "D29",
        "D30",
        "D31",
        ];

    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_D register, bool upperCase = false) => upperCase ? RegisterV_DUpperNames[ValidateRegisterIndex(register.Index)] : RegisterV_DLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV_DLowerNames = [
        "v0.d",
        "v1.d",
        "v2.d",
        "v3.d",
        "v4.d",
        "v5.d",
        "v6.d",
        "v7.d",
        "v8.d",
        "v9.d",
        "v10.d",
        "v11.d",
        "v12.d",
        "v13.d",
        "v14.d",
        "v15.d",
        "v16.d",
        "v17.d",
        "v18.d",
        "v19.d",
        "v20.d",
        "v21.d",
        "v22.d",
        "v23.d",
        "v24.d",
        "v25.d",
        "v26.d",
        "v27.d",
        "v28.d",
        "v29.d",
        "v30.d",
        "v31.d",
        ];

    private static readonly string[] RegisterV_DUpperNames = [
        "V0.D",
        "V1.D",
        "V2.D",
        "V3.D",
        "V4.D",
        "V5.D",
        "V6.D",
        "V7.D",
        "V8.D",
        "V9.D",
        "V10.D",
        "V11.D",
        "V12.D",
        "V13.D",
        "V14.D",
        "V15.D",
        "V16.D",
        "V17.D",
        "V18.D",
        "V19.D",
        "V20.D",
        "V21.D",
        "V22.D",
        "V23.D",
        "V24.D",
        "V25.D",
        "V26.D",
        "V27.D",
        "V28.D",
        "V29.D",
        "V30.D",
        "V31.D",
        ];


    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_1D register, bool upperCase = false) => upperCase ? RegisterV1DUpperNames[ValidateRegisterIndex(register.Index)] : RegisterV1DLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV1DLowerNames = [
        "v0.1d",
        "v1.1d",
        "v2.1d",
        "v3.1d",
        "v4.1d",
        "v5.1d",
        "v6.1d",
        "v7.1d",
        "v8.1d",
        "v9.1d",
        "v10.1d",
        "v11.1d",
        "v12.1d",
        "v13.1d",
        "v14.1d",
        "v15.1d",
        "v16.1d",
        "v17.1d",
        "v18.1d",
        "v19.1d",
        "v20.1d",
        "v21.1d",
        "v22.1d",
        "v23.1d",
        "v24.1d",
        "v25.1d",
        "v26.1d",
        "v27.1d",
        "v28.1d",
        "v29.1d",
        "v30.1d",
        "v31.1d",
        ];

    private static readonly string[] RegisterV1DUpperNames = [
        "V0.1D",
        "V1.1D",
        "V2.1D",
        "V3.1D",
        "V4.1D",
        "V5.1D",
        "V6.1D",
        "V7.1D",
        "V8.1D",
        "V9.1D",
        "V10.1D",
        "V11.1D",
        "V12.1D",
        "V13.1D",
        "V14.1D",
        "V15.1D",
        "V16.1D",
        "V17.1D",
        "V18.1D",
        "V19.1D",
        "V20.1D",
        "V21.1D",
        "V22.1D",
        "V23.1D",
        "V24.1D",
        "V25.1D",
        "V26.1D",
        "V27.1D",
        "V28.1D",
        "V29.1D",
        "V30.1D",
        "V31.1D",
        ];

    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_2D register, bool upperCase = false) => upperCase ? RegisterV2DUpperNames[ValidateRegisterIndex(register.Index)] : RegisterV2DLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV2DLowerNames = [
        "v0.2d",
        "v1.2d",
        "v2.2d",
        "v3.2d",
        "v4.2d",
        "v5.2d",
        "v6.2d",
        "v7.2d",
        "v8.2d",
        "v9.2d",
        "v10.2d",
        "v11.2d",
        "v12.2d",
        "v13.2d",
        "v14.2d",
        "v15.2d",
        "v16.2d",
        "v17.2d",
        "v18.2d",
        "v19.2d",
        "v20.2d",
        "v21.2d",
        "v22.2d",
        "v23.2d",
        "v24.2d",
        "v25.2d",
        "v26.2d",
        "v27.2d",
        "v28.2d",
        "v29.2d",
        "v30.2d",
        "v31.2d",
        ];

    private static readonly string[] RegisterV2DUpperNames = [
        "V0.2D",
        "V1.2D",
        "V2.2D",
        "V3.2D",
        "V4.2D",
        "V5.2D",
        "V6.2D",
        "V7.2D",
        "V8.2D",
        "V9.2D",
        "V10.2D",
        "V11.2D",
        "V12.2D",
        "V13.2D",
        "V14.2D",
        "V15.2D",
        "V16.2D",
        "V17.2D",
        "V18.2D",
        "V19.2D",
        "V20.2D",
        "V21.2D",
        "V22.2D",
        "V23.2D",
        "V24.2D",
        "V25.2D",
        "V26.2D",
        "V27.2D",
        "V28.2D",
        "V29.2D",
        "V30.2D",
        "V31.2D",
        ];
    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterQ register, bool upperCase = false) => upperCase ? RegisterVScalarQUpperNames[ValidateRegisterIndex(register.Index)] : RegisterVScalarQLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterVScalarQLowerNames = [
        "q0",
        "q1",
        "q2",
        "q3",
        "q4",
        "q5",
        "q6",
        "q7",
        "q8",
        "q9",
        "q10",
        "q11",
        "q12",
        "q13",
        "q14",
        "q15",
        "q16",
        "q17",
        "q18",
        "q19",
        "q20",
        "q21",
        "q22",
        "q23",
        "q24",
        "q25",
        "q26",
        "q27",
        "q28",
        "q29",
        "q30",
        "q31",
        ];

    private static readonly string[] RegisterVScalarQUpperNames = [
        "Q0",
        "Q1",
        "Q2",
        "Q3",
        "Q4",
        "Q5",
        "Q6",
        "Q7",
        "Q8",
        "Q9",
        "Q10",
        "Q11",
        "Q12",
        "Q13",
        "Q14",
        "Q15",
        "Q16",
        "Q17",
        "Q18",
        "Q19",
        "Q20",
        "Q21",
        "Q22",
        "Q23",
        "Q24",
        "Q25",
        "Q26",
        "Q27",
        "Q28",
        "Q29",
        "Q30",
        "Q31",
        ];

    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_Q register, bool upperCase = false) => upperCase ? RegisterV_QUpperNames[ValidateRegisterIndex(register.Index)] : RegisterV_QLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV_QLowerNames = [
        "v0.q",
        "v1.q",
        "v2.q",
        "v3.q",
        "v4.q",
        "v5.q",
        "v6.q",
        "v7.q",
        "v8.q",
        "v9.q",
        "v10.q",
        "v11.q",
        "v12.q",
        "v13.q",
        "v14.q",
        "v15.q",
        "v16.q",
        "v17.q",
        "v18.q",
        "v19.q",
        "v20.q",
        "v21.q",
        "v22.q",
        "v23.q",
        "v24.q",
        "v25.q",
        "v26.q",
        "v27.q",
        "v28.q",
        "v29.q",
        "v30.q",
        "v31.q",
        ];

    private static readonly string[] RegisterV_QUpperNames = [
        "V0.Q",
        "V1.Q",
        "V2.Q",
        "V3.Q",
        "V4.Q",
        "V5.Q",
        "V6.Q",
        "V7.Q",
        "V8.Q",
        "V9.Q",
        "V10.Q",
        "V11.Q",
        "V12.Q",
        "V13.Q",
        "V14.Q",
        "V15.Q",
        "V16.Q",
        "V17.Q",
        "V18.Q",
        "V19.Q",
        "V20.Q",
        "V21.Q",
        "V22.Q",
        "V23.Q",
        "V24.Q",
        "V25.Q",
        "V26.Q",
        "V27.Q",
        "V28.Q",
        "V29.Q",
        "V30.Q",
        "V31.Q",
        ];


    /// <summary>
    /// Converts the V register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_1Q register, bool upperCase = false) => upperCase ? RegisterV1QUpperNames[ValidateRegisterIndex(register.Index)] : RegisterV1QLowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV1QLowerNames = [
        "v0.1q",
        "v1.1q",
        "v2.1q",
        "v3.1q",
        "v4.1q",
        "v5.1q",
        "v6.1q",
        "v7.1q",
        "v8.1q",
        "v9.1q",
        "v10.1q",
        "v11.1q",
        "v12.1q",
        "v13.1q",
        "v14.1q",
        "v15.1q",
        "v16.1q",
        "v17.1q",
        "v18.1q",
        "v19.1q",
        "v20.1q",
        "v21.1q",
        "v22.1q",
        "v23.1q",
        "v24.1q",
        "v25.1q",
        "v26.1q",
        "v27.1q",
        "v28.1q",
        "v29.1q",
        "v30.1q",
        "v31.1q",
        ];

    private static readonly string[] RegisterV1QUpperNames = [
        "V0.1Q",
        "V1.1Q",
        "V2.1Q",
        "V3.1Q",
        "V4.1Q",
        "V5.1Q",
        "V6.1Q",
        "V7.1Q",
        "V8.1Q",
        "V9.1Q",
        "V10.1Q",
        "V11.1Q",
        "V12.1Q",
        "V13.1Q",
        "V14.1Q",
        "V15.1Q",
        "V16.1Q",
        "V17.1Q",
        "V18.1Q",
        "V19.1Q",
        "V20.1Q",
        "V21.1Q",
        "V22.1Q",
        "V23.1Q",
        "V24.1Q",
        "V25.1Q",
        "V26.1Q",
        "V27.1Q",
        "V28.1Q",
        "V29.1Q",
        "V30.1Q",
        "V31.1Q",
        ];
}
