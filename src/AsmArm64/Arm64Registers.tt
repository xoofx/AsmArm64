<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var registerKinds = new string[] { "X", "W", "SP", "V" };
    var vectors = new (string Name, string Description, int[] Sizes) [] {
        ("B", "8-bit vector register", new int[] {8, 16}),
        ("H", "Half-precision 16-bit floating-point register", new int[] {4, 8}),
        ("S", "Single-precision 32-bit floating-point register", new int[] {2, 4}),
        ("D", "Double-precision 64-bit floating-point register", new int[] {2})
    };
    var registerKindNames = new Dictionary<string, string>
    {
        { "X", "64-bit general-purpose register" },
        { "XZ","Zero 64-bit register" },
        { "W", "32-bit general-purpose register" },
        { "WZ","Zero 32-bit register" },
        { "SP", "Stack pointer register" },
        { "V", "Vector register" },
        { "H", "Half-precision 16-bit floating-point register" },
        { "S", "Single-precision 32-bit floating-point register" },
        { "D", "Double-precision 64-bit floating-point register" },
    };
#>
// Copyright (c) Alexandre Mutel. All rights reserved.
// Licensed under the BSD-Clause 2 license.
// See license.txt file in the project root for full license information.

using System.Runtime.CompilerServices;

// ReSharper disable InconsistentNaming
namespace AsmArm64;

/// <summary>
/// Defines the kind of register.
/// </summary>
public enum Arm64RegisterKind : byte
{
    /// <summary>
    /// Invalid register kind.
    /// </summary>
    Invalid = 0,
<# foreach(var kind in registerKinds) { #>
    /// <summary>
    /// <#= registerKindNames[kind] #>.
    /// </summary>
    <#= kind #>,
<# } #>
    /// <summary>
    /// Vector Typed register (Vn.8B, Vn.16B, Vn.4H, Vn.8H, Vn.2S, Vn.4S, Vn.2D).
    /// </summary>
    VTyped,
    /// <summary>
    /// Vector Scalar element (e.g. H0 / S0 / D0).
    /// </summary>
    VScalar,
}

/// <summary>
/// Defines the kind of vector typed register (e.g. Vn.8B).
/// </summary>
public enum Arm64RegisterVKind : byte
{
    /// <summary>
    /// The full vector register.
    /// </summary>
    Full = 0,
<# foreach(var v in vectors) { #>
    /// <summary>
    /// <#= v.Description #>.
    /// </summary>
    <#= v.Name #>,
<# } #>
}
<# foreach(var kind in registerKinds) { #>

/// <summary>
/// Represents an ARM64 <#= kind #> <#= registerKindNames[kind] #>.
/// </summary>
public readonly record struct Arm64Register<#= kind #> : <#= kind == "V" ? "IArm64RegisterV" : "IArm64Register" #>
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Arm64Register<#= kind #>(int index) => _value = (uint)Arm64RegisterKind.<#= kind #> << 8 | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;
<# if (kind == "V") { #>

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => Arm64RegisterVKind.Full;
<# foreach(var vector in vectors) { var vkind = vector.Name; #>
<# foreach(var size in vector.Sizes) { #>

    /// <summary>
    /// Gets the <#= size #> x <#= vkind #> <#= kind #> register.
    /// </summary>
    public Arm64RegisterV<#= size #><#= vkind #> T<#= size #><#= vkind #> => new(Index);
<# } // foreach size #>
<# } // foreach vector #>
<# } // if kind == V #>

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }
<# if (kind == "SP") { #>

    /// <summary>
    /// Gets the <#= kind #> register.
    /// </summary>
    public static Arm64Register<#= kind #> <#= kind #> => new(31);
<# } else if (kind == "X") { #>
<# for(int i = 0; i < 31; i++) { #>

    /// <summary>
    /// Gets the <#= kind #><#= i #> register.
    /// </summary>
    public static Arm64Register<#= kind #> <#= kind #><#= i #> => new(<#= i #>);
<# } #>

    /// <summary>
    /// Gets the XZR register.
    /// </summary>
    public static Arm64RegisterX XZR => new(31);
<# } else if (kind == "W") { #>
<# for(int i = 0; i < 31; i++) { #>

    /// <summary>
    /// Gets the <#= kind #><#= i #> register.
    /// </summary>
    public static Arm64Register<#= kind #> <#= kind #><#= i #> => new(<#= i #>);
<# } #>

    /// <summary>
    /// Gets the WZR register.
    /// </summary>
    public static Arm64RegisterW WZR => new(31);
<# } else if (kind == "V") { #>
<# for(int i = 0; i < 32; i++) { #>

    /// <summary>
    /// Gets the <#= kind #><#= i #> register.
    /// </summary>
    public static Arm64Register<#= kind #> <#= kind #><#= i #> => new(<#= i #>);
<# } #>
<# } // else #>
}
<# } // foreach kind #>
<# foreach(var vector in vectors) { var kind = vector.Name; #>
<# if (kind != "B") { #>

/// <summary>
/// Represents an ARM64 a <#= vector.Description #> (<#= kind #> arrangement).
/// </summary>
public readonly record struct Arm64RegisterVScalar<#= kind #> : IArm64RegisterVScalar
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterVScalar<#= kind #>(int index) => _value = (uint)Arm64RegisterVKind.<#= kind #> << 16 | (uint)Arm64RegisterKind.VScalar << 8 | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }
<# for(int i = 0; i < 32; i++) { #>

    /// <summary>
    /// Gets the <#= kind #><#= i #> register.
    /// </summary>
    public static Arm64RegisterVScalar<#= kind #> <#= kind #><#= i #> => new(<#= i #>);
<# } #>
}
<# } // if (kind != "B") #>
<# foreach(var size in vector.Sizes) { #>

/// <summary>
/// Represents an ARM64 an arranged <#= size #> x <#= kind #>, <#= vector.Description #>
/// </summary>
public readonly record struct Arm64RegisterV<#= size #><#= kind #> : IArm64RegisterVTyped
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV<#= size #><#= kind #>(int index) => _value = <#= size #>U << 24 | (uint)Arm64RegisterVKind.<#= kind #> << 16 | (uint)Arm64RegisterKind.V << 8 | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public int ElementCount => (int)(_value >> 24);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }
}
<# } } // foreach size / kind #>

partial class Arm64Factory
{
    /// <summary>
    /// Gets the XZR register.
    /// </summary>
    public static Arm64RegisterX XZR => Arm64RegisterX.XZR;

        /// <summary>
    /// Gets the WZR register.
    /// </summary>
    public static Arm64RegisterW WZR => Arm64RegisterW.WZR;
<# foreach(var kind in registerKinds) { #>
<# if (kind == "SP") { #>
    /// <summary>
    /// Gets the <#= kind #> register.
    /// </summary>
    public static Arm64Register<#= kind #> <#= kind #> =>  Arm64RegisterSP.SP;
<# } else { #>
<# for(int i = 0; i < ((kind == "X" || kind == "W") ? 31 : 32); i++) { #>
    /// <summary>
    /// Gets the <#= kind #><#= i #> register.
    /// </summary>
    public static Arm64Register<#= kind #> <#= kind #><#= i #> => Arm64Register<#= kind #>.<#= kind #><#= i #>;
<# }
}
}
#>
}

partial class Arm64Extensions
{
<# foreach(var kind in registerKinds) { #>
    /// <summary>
    /// Converts the <#= kind #> register to a string.
    /// </summary>
    public static string ToText(this Arm64Register<#= kind #> register, bool upperCase = false) => upperCase ? Register<#= kind #>UpperNames[register.Index] : Register<#= kind #>LowerNames[register.Index];
<# if (kind == "SP") { #>
    private static readonly string[] RegisterSPLowerNames = [
<# for(int i = 0; i < 31; i++) { #>
        "??", // <#= i #>
<# } #>
        "sp", // 31
    ];

    private static readonly string[] RegisterSPUpperNames = [
<# for(int i = 0; i < 31; i++) { #>
        "??", // <#= i #>
<# } #>
        "SP", // 31
    ];
<# } else { #>

    private static readonly string[] Register<#= kind #>LowerNames = [
<# for(int i = 0; i < ((kind == "X" || kind == "W") ? 31 : 32); i++) { #>
        "<#= kind.ToLowerInvariant() #><#= i #>",
<# } if (kind == "X" || kind == "W") { #>
        "<#= kind.ToLowerInvariant() #>zr",
<# } #>
    ];

    private static readonly string[] Register<#= kind #>UpperNames = [
<# for(int i = 0; i < ((kind == "X" || kind == "W") ? 31 : 32); i++) { #>
        "<#= kind #><#= i #>",
<# } if (kind == "X" || kind == "W") { #>
        "<#= kind #>ZR",
<# } #>
    ];
<# if (kind == "V") { #>
<# foreach(var vector in vectors) { var vkind = vector.Name; #>
<# if (vkind != "B") { #>
    /// <summary>
    /// Converts the <#= kind #> register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterVScalar<#= vkind #> register, bool upperCase = false) => upperCase ? RegisterVScalar<#= vkind #>UpperNames[register.Index] : RegisterVScalar<#= vkind #>LowerNames[register.Index];

    private static readonly string[] RegisterVScalar<#= vkind #>LowerNames = [
    <# for(int i = 0; i < 32; i++) { #>
    "<#= vkind.ToLowerInvariant() #><#= i #>",
    <# } #>
    ];

    private static readonly string[] RegisterVScalar<#= vkind #>UpperNames = [
    <# for(int i = 0; i < 32; i++) { #>
    "<#= vkind #><#= i #>",
    <# } #>
    ];
<# } // if (vkind != "B") #>
<# foreach(var size in vector.Sizes) { #>

    /// <summary>
    /// Converts the <#= kind #> register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV<#= size #><#= vkind #> register, bool upperCase = false) => upperCase ? RegisterV<#= size #><#= vkind #>UpperNames[register.Index] : RegisterV<#= size #><#= vkind #>LowerNames[register.Index];

    private static readonly string[] RegisterV<#= size #><#= vkind #>LowerNames = [
    <# for(int i = 0; i < 32; i++) { #>
    "<#= kind.ToLowerInvariant() #><#= i #>.<#= size #><#= vkind.ToLowerInvariant() #>",
    <# } #>
    ];

    private static readonly string[] RegisterV<#= size #><#= vkind #>UpperNames = [
    <# for(int i = 0; i < 32; i++) { #>
    "<#= kind #><#= i #>.<#= size #><#= vkind #>",
    <# } #>
    ];
<# } // foreach size #>
<# } // foreach vector #>
<# } // if (kind == "V") #>
<# } // else #>
<# } // foreach kind #>
}
