<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var registerKinds = new string[] { "X", "W", "C", "SP", "WSP", "V" };
    var vectors = new (string Name, string Description, int[] Sizes) [] {
        ("B", "8-bit vector register", new int[] {2, 4, 8, 16}),
        ("H", "Half-precision 16-bit floating-point register", new int[] {2, 4, 8}),
        ("S", "Single-precision 32-bit floating-point register", new int[] {2, 4}),
        ("D", "Double-precision 64-bit floating-point register", new int[] {1, 2}),
        ("Q", "Double-precision 64-bit floating-point register", new int[] {1})
    };

    var registerKindNames = new Dictionary<string, string>
    {
        { "X", "64-bit general-purpose register" },
        { "XZ","Zero 64-bit register" },
        { "W", "32-bit general-purpose register" },
        { "WZ","Zero 32-bit register" },
        { "SP", "32-bit Stack pointer register" },
        { "WSP", "32-bit Stack pointer register" },
        { "C", "Control Register" },
        { "V", "Vector register" },
        { "H", "Half-precision 16-bit floating-point register" },
        { "S", "Single-precision 32-bit floating-point register" },
        { "D", "Double-precision 64-bit floating-point register" },
    };

    var toElementShift = (int a) => a switch
    {
        0 => 0,
        1 => 1,
        2 => 2,
        4 => 3,
        8 => 4,
        16 => 5,
        _ => throw new InvalidOperationException($"Value {a} is not supported as an element count")
    };
#>
// Copyright (c) Alexandre Mutel. All rights reserved.
// Licensed under the BSD-Clause 2 license.
// See license.txt file in the project root for full license information.

// This file is automatically generated. DO NOT EDIT. Changes will be lost if the file is regenerated.

using System.Runtime.CompilerServices;

// ReSharper disable InconsistentNaming
namespace AsmArm64;

/// <summary>
/// Defines the kind of register.
/// </summary>
public enum Arm64RegisterKind : byte
{
    /// <summary>
    /// Invalid register kind.
    /// </summary>
    Invalid = 0,
<# foreach(var kind in registerKinds) { #>
    /// <summary>
    /// <#= registerKindNames[kind] #>.
    /// </summary>
    <#= kind #>,
<# } #>
    /// <summary>
    /// Vector Typed register (Vn.8B, Vn.16B, Vn.4H, Vn.8H, Vn.2S, Vn.4S, Vn.2D).
    /// </summary>
    VPacked,
    /// <summary>
    /// Vector Indexed register (Vn.2B[0], Vn.4B[1], Vn.2H[2]).
    /// </summary>
    VPackedIndexed,
    /// <summary>
    /// Vector Typed register (Vn.B, Vn.H, Vn.S, Vn.D).
    /// </summary>
    VTyped,
    /// <summary>
    /// Vector Indexed register (Vn.B[0], Vn.H[1], Vn.S[2], Vn.D[0]).
    /// </summary>
    VTypedIndexed,
    /// <summary>
    /// Vector Scalar element (e.g. H0 / S0 / D0).
    /// </summary>
    VScalar,
}

/// <summary>
/// Defines the kind of vector typed register (e.g. Vn.8B).
/// </summary>
public enum Arm64RegisterVKind : byte
{
    /// <summary>
    /// The default vector register (or none for a non vector register).
    /// </summary>
    Default = 0,
<# foreach(var v in vectors) { #>
    /// <summary>
    /// <#= v.Description #>.
    /// </summary>
    <#= v.Name #>,
<# } #>
}
<# foreach(var kind in registerKinds) { #>

/// <summary>
/// Represents an ARM64 <#= kind #> <#= registerKindNames[kind] #>.
/// </summary>
public readonly record struct Arm64Register<#= kind #> : <#= kind == "V" ? "IArm64RegisterV" : "IArm64Register" #>
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64Register<#= kind #>(int index) => _value = ((uint)Arm64RegisterKind.<#= kind #> << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;
<# if (kind == "V") { #>

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => Arm64RegisterVKind.Default;
<# foreach(var vector in vectors) { var vkind = vector.Name; if (vkind == "Q") continue; #>

    /// <summary>
    /// Gets the V.<#= vkind #> register.
    /// </summary>
    public Arm64RegisterV_<#= vkind #> <#= vkind #> => new(Index);
<# foreach(var size in vector.Sizes) { #>

    /// <summary>
    /// Gets the <#= size #> x <#= vkind #> <#= kind #> register.
    /// </summary>
    public Arm64RegisterV_<#= size #><#= vkind #> T_<#= size #><#= vkind #> => new(Index);
<# } // foreach size #>
<# } // foreach vector #>
<# } // if kind == V #>

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64Register<#= kind #> register) => Unsafe.BitCast<Arm64Register<#= kind #>, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register register to a <#= kind #> register.
    /// </summary>
    public static explicit operator Arm64Register<#= kind #>(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.<#= kind #> || register.VKind != Arm64RegisterVKind.Default)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind} to Arm64RegisterKind.<#= kind #>");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64Register<#= kind #>>(register);
    }
<# if (kind == "SP" || kind == "WSP") { #>

    /// <summary>
    /// Gets the <#= kind #> register.
    /// </summary>
    public static Arm64Register<#= kind #> <#= kind #> => new(31);
<# } else if (kind == "C") { #>
<# for(int i = 0; i < 16; i++) { #>

    /// <summary>
    /// Gets the <#= kind #><#= i #> register.
    /// </summary>
    public static Arm64Register<#= kind #> <#= kind #><#= i #> => new(<#= i #>);
<# } #>
<# } else if (kind == "X") { #>
<# for(int i = 0; i < 31; i++) { #>

    /// <summary>
    /// Gets the <#= kind #><#= i #> register.
    /// </summary>
    public static Arm64Register<#= kind #> <#= kind #><#= i #> => new(<#= i #>);
<# } #>

    /// <summary>
    /// Gets the XZR register.
    /// </summary>
    public static Arm64RegisterX XZR => new(31);
<# } else if (kind == "W") { #>
<# for(int i = 0; i < 31; i++) { #>

    /// <summary>
    /// Gets the <#= kind #><#= i #> register.
    /// </summary>
    public static Arm64Register<#= kind #> <#= kind #><#= i #> => new(<#= i #>);
<# } #>

    /// <summary>
    /// Gets the WZR register.
    /// </summary>
    public static Arm64RegisterW WZR => new(31);
<# } else if (kind == "V") { #>
<# for(int i = 0; i < 32; i++) { #>

    /// <summary>
    /// Gets the <#= kind #><#= i #> register.
    /// </summary>
    public static Arm64Register<#= kind #> <#= kind #><#= i #> => new(<#= i #>);
<# } #>
<# } // else #>
}
<# } // foreach kind #>
<# foreach(var vector in vectors) { var kind = vector.Name; #>
/// <summary>
/// Represents an ARM64 a vector typed with <#= vector.Description #> (V.<#= kind #> arrangement).
/// </summary>
public readonly record struct Arm64RegisterV_<#= kind #> : IArm64RegisterVTyped
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_<#= kind #>(int index) => _value = ((uint)Arm64RegisterVKind.<#= kind #> << 16) | ((uint)Arm64RegisterKind.VTyped << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <summary>
    /// Gets the indexed element of this vector typed register.
    /// </summary>
    public Indexed this[int elementIndex] => new(Index, elementIndex);

    /// <summary>
    /// Gets the base register of this vector typed register.
    /// </summary>
    public Arm64RegisterV BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_<#= kind #> register) => Unsafe.BitCast<Arm64RegisterV_<#= kind #>, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.<#= kind #> register.
    /// </summary>
    public static explicit operator Arm64RegisterV_<#= kind #>(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VTyped || register.VKind != Arm64RegisterVKind.<#= kind #>)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_<#= kind #>");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_<#= kind #>>(register);
    }

    /// <summary>
    /// Represents an ARM64 a vector indexed with <#= vector.Description #> (V.<#= kind #> arrangement).
    /// </summary>
    public readonly record struct Indexed : IArm64RegisterVTyped, IArm64RegisterVIndexed
    {
        private readonly uint _value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal Indexed(int registerIndex, int elementIndex) => _value = ((uint)elementIndex << 28) | ((uint)Arm64RegisterVKind.<#= kind #> << 16) | ((uint)Arm64RegisterKind.VTypedIndexed << 8) | (uint)registerIndex;

        /// <inheritdoc />
        public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

        /// <inheritdoc />
        public int Index => (byte)_value;

        /// <inheritdoc />
        public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

        /// <inheritdoc />
        public int ElementIndex => (byte)(_value >> 28);

        /// <summary>
        /// Gets the base register of this indexed vector register.
        /// </summary>
        public Arm64RegisterV_<#= kind #> BaseRegister => new(Index);

        /// <inheritdoc />
        public override string ToString() => ToString(null, null);

        /// <inheritdoc />
        [SkipLocalsInit]
        public string ToString(string? format, IFormatProvider? formatProvider)
        {
            Span<char> localText = stackalloc char[16];
            return !TryFormat(localText, out var charsWritten, format, formatProvider) ? string.Empty : localText.Slice(0, charsWritten).ToString();
        }

        /// <inheritdoc />
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            if (!BaseRegister.TryFormat(destination, out var tempWritten, format, provider))
            {
                charsWritten = 0;
                return false;
            }
            // [1] to [16] (3 to 4 characters)
            if (destination.Length < tempWritten + 4)
            {
                charsWritten = 0;
                return false;
            }
            destination[tempWritten] = '[';
            if (ElementIndex >= 10)
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex / 10);
                destination[tempWritten + 2] = (char)('0' + ElementIndex % 10);
                charsWritten = tempWritten + 3;
            }
            else
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex);
                charsWritten = tempWritten + 2;
            }
            destination[charsWritten] = ']';

            charsWritten++;
            return true;
        }

        /// <summary>
        /// Converts this register to an any register.
        /// </summary>
        public static implicit operator Arm64RegisterAny(Indexed register) => Unsafe.BitCast<Indexed, Arm64RegisterAny>(register);

        /// <summary>
        /// Converts an any register to a V.<#= kind #> register.
        /// </summary>
        public static explicit operator Indexed(Arm64RegisterAny register)
        {
            if (register.Kind != Arm64RegisterKind.VTypedIndexed || register.VKind != Arm64RegisterVKind.<#= kind #>)
            {
                throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_<#= kind #>.Indexed");
            }
            return Unsafe.BitCast<Arm64RegisterAny, Indexed>(register);
        }
    }
}

/// <summary>
/// Represents an ARM64 a <#= vector.Description #> (<#= kind #> arrangement).
/// </summary>
public readonly record struct Arm64Register<#= kind #> : IArm64RegisterVScalar
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64Register<#= kind #>(int index) => _value = ((uint)Arm64RegisterVKind.<#= kind #> << 16) | ((uint)Arm64RegisterKind.VScalar << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64Register<#= kind #> register) => Unsafe.BitCast<Arm64Register<#= kind #>, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.<#= kind #> register.
    /// </summary>
    public static explicit operator Arm64Register<#= kind #>(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VScalar || register.VKind != Arm64RegisterVKind.<#= kind #>)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64Register<#= kind #>");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64Register<#= kind #>>(register);
    }
<# for(int i = 0; i < 32; i++) { #>

    /// <summary>
    /// Gets the <#= kind #><#= i #> register.
    /// </summary>
    public static Arm64Register<#= kind #> <#= kind #><#= i #> => new(<#= i #>);
<# } #>
}

<# foreach(var size in vector.Sizes) { #>

/// <summary>
/// Represents an ARM64 an arranged <#= size #> x <#= kind #>, <#= vector.Description #>
/// </summary>
public readonly record struct Arm64RegisterV_<#= size #><#= kind #> : IArm64RegisterVPacked
{
    private readonly uint _value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal Arm64RegisterV_<#= size #><#= kind #>(int index) => _value = (<#= toElementShift(size) #>U << 24) | ((uint)Arm64RegisterVKind.<#= kind #> << 16) | ((uint)Arm64RegisterKind.VPacked << 8) | (uint)index;

    /// <inheritdoc />
    public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

    /// <inheritdoc />
    public int Index => (byte)_value;

    /// <inheritdoc />
    public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

    /// <inheritdoc />
    public int ElementCount => Arm64RegisterAny.ToElementCount((_value >> 24) & 0xF);

    /// <summary>
    /// Gets the base register of this vector packed register.
    /// </summary>
    public Arm64RegisterV_<#= kind #> BaseRegister => new(Index);

    /// <inheritdoc />
    public override string ToString() => ToString(null, null);

    /// <inheritdoc />
    public string ToString(string? format, IFormatProvider? formatProvider) => this.ToText((format ??= "L") == "H");

    /// <inheritdoc />
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
    {
        if (format.Length != 1) format = "L";
        var text = this.ToText(format[0] == 'H');
        var result = text.AsSpan().TryCopyTo(destination);
        charsWritten = result ? text.Length : 0;
        return result;
    }

    /// <summary>
    /// Converts this register to an any register.
    /// </summary>
    public static implicit operator Arm64RegisterAny(Arm64RegisterV_<#= size #><#= kind #> register) => Unsafe.BitCast<Arm64RegisterV_<#= size #><#= kind #>, Arm64RegisterAny>(register);

    /// <summary>
    /// Converts an any register to a V.<#= kind #> register.
    /// </summary>
    public static explicit operator Arm64RegisterV_<#= size #><#= kind #>(Arm64RegisterAny register)
    {
        if (register.Kind != Arm64RegisterKind.VPacked || register.VKind != Arm64RegisterVKind.<#= kind #>)
        {
            throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_<#= size #><#= kind #>");
        }
        return Unsafe.BitCast<Arm64RegisterAny, Arm64RegisterV_<#= size #><#= kind #>>(register);
    }
<# var combo = $"{size}{kind}"; if (combo == "2B" || combo == "4B" || combo == "2H") {#>

    /// <summary>
    /// Gets the indexed element of this vector packed register.
    /// </summary>
    public Indexed this[int elementIndex] => new(Index, elementIndex);

    /// <summary>
    /// Represents an ARM64 a vector indexed with (V.<#= kind #> arrangement).
    /// </summary>
    public readonly record struct Indexed : IArm64RegisterVPacked, IArm64RegisterVIndexed
    {
        private readonly uint _value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal Indexed(int registerIndex, int elementIndex) => _value = ((uint)elementIndex << 28) | (<#= toElementShift(size) #>U << 24) | ((uint)Arm64RegisterVKind.<#= kind #> << 16) | ((uint)Arm64RegisterKind.VPackedIndexed << 8) | (uint)registerIndex;

        /// <inheritdoc />
        public Arm64RegisterKind Kind => (Arm64RegisterKind)(_value >> 8);

        /// <inheritdoc />
        public int Index => (byte)_value;

        /// <inheritdoc />
        public Arm64RegisterVKind VKind => (Arm64RegisterVKind)(_value >> 16);

        /// <inheritdoc />
        public int ElementCount => (byte)((_value >> 24) & 0xF) << 1;

        /// <inheritdoc />
        public int ElementIndex => (byte)(_value >> 28);

        /// <summary>
        /// Gets the base register of this indexed vector register.
        /// </summary>
        public Arm64RegisterV_<#= size #><#= kind #> BaseRegister => new(Index);

        /// <inheritdoc />
        public override string ToString() => ToString(null, null);

        /// <inheritdoc />
        [SkipLocalsInit]
        public string ToString(string? format, IFormatProvider? formatProvider)
        {
            Span<char> localText = stackalloc char[16];
            return !TryFormat(localText, out var charsWritten, format, formatProvider) ? string.Empty : localText.Slice(0, charsWritten).ToString();
        }

        /// <inheritdoc />
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            if (!BaseRegister.TryFormat(destination, out var tempWritten, format, provider))
            {
                charsWritten = 0;
                return false;
            }
            // [1] to [16] (3 to 4 characters)
            if (destination.Length < tempWritten + 4)
            {
                charsWritten = 0;
                return false;
            }
            destination[tempWritten] = '[';
            if (ElementIndex >= 10)
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex / 10);
                destination[tempWritten + 2] = (char)('0' + ElementIndex % 10);
                charsWritten = tempWritten + 3;
            }
            else
            {
                destination[tempWritten + 1] = (char)('0' + ElementIndex);
                charsWritten = tempWritten + 2;
            }
            destination[charsWritten] = ']';

            charsWritten++;
            return true;
        }

        /// <summary>
        /// Converts this register to an any register.
        /// </summary>
        public static implicit operator Arm64RegisterAny(Indexed register) => Unsafe.BitCast<Indexed, Arm64RegisterAny>(register);

        /// <summary>
        /// Converts an any register to a V.<#= kind #> register.
        /// </summary>
        public static explicit operator Indexed(Arm64RegisterAny register)
        {
            if (register.Kind != Arm64RegisterKind.VPackedIndexed || register.VKind != Arm64RegisterVKind.<#= kind #>)
            {
                throw new InvalidCastException($"Invalid cast from {register.Kind}/{register.VKind} to Arm64RegisterV_<#= size #><#= kind #>.Indexed");
            }
            return Unsafe.BitCast<Arm64RegisterAny, Indexed>(register);
        }
    }
<# } // if combo == "2B" || combo == "4B" || combo == "2H" #>
}
<# } } // foreach size / kind #>

partial class Arm64Factory
{
    /// <summary>
    /// Gets the XZR register.
    /// </summary>
    public static Arm64RegisterX XZR => Arm64RegisterX.XZR;

        /// <summary>
    /// Gets the WZR register.
    /// </summary>
    public static Arm64RegisterW WZR => Arm64RegisterW.WZR;
<# foreach(var kind in registerKinds) { #>
<# if (kind == "SP" || kind == "WSP") { #>
    /// <summary>
    /// Gets the <#= kind #> register.
    /// </summary>
    public static Arm64Register<#= kind #> <#= kind #> =>  Arm64Register<#= kind #>.<#= kind #>;
<# } else { #>
<# for(int i = 0; i < ((kind == "X" || kind == "W") ? 31 : (kind == "C" ? 16 : 32)); i++) { #>
    /// <summary>
    /// Gets the <#= kind #><#= i #> register.
    /// </summary>
    public static Arm64Register<#= kind #> <#= kind #><#= i #> => Arm64Register<#= kind #>.<#= kind #><#= i #>;
<# } // for #>
<# } // else #>
<# } // foreach kind #>

<# foreach(var vector in vectors) { var vkind = vector.Name; if (vkind == "B") continue; #>
<# for(int i = 0; i < 32; i++) { #>
    /// <summary>
    /// Gets the <#= vkind #><#= i #> register.
    /// </summary>
    public static Arm64Register<#= vkind #> <#= vkind #><#= i #> => Arm64Register<#= vkind #>.<#= vkind #><#= i #>;
<# } // for #>
<# } // foreach vector #>
}

partial class Arm64Extensions
{
<# foreach(var kind in registerKinds) { #>
    /// <summary>
    /// Converts the <#= kind #> register to a string.
    /// </summary>
    public static string ToText(this Arm64Register<#= kind #> register, bool upperCase = false) => upperCase ? Register<#= kind #>UpperNames[ValidateRegisterIndex(register.Index)] : Register<#= kind #>LowerNames[ValidateRegisterIndex(register.Index)];
<# if (kind == "SP" || kind == "WSP") { #>
    private static readonly string[] Register<#= kind #>LowerNames = [
<# for(int i = 0; i < 31; i++) { #>
        "??", // <#= i #>
<# } #>
        "<#= kind.ToLowerInvariant() #>", // 31
    ];

    private static readonly string[] Register<#= kind #>UpperNames = [
<# for(int i = 0; i < 31; i++) { #>
        "??", // <#= i #>
<# } #>
        "<#= kind #>", // 31
    ];
<# } else { #>

    private static readonly string[] Register<#= kind #>LowerNames = [
<# for(int i = 0; i < ((kind == "X" || kind == "W") ? 31 : (kind == "C" ? 16 : 32)); i++) { #>
        "<#= kind.ToLowerInvariant() #><#= i #>",
<# } if (kind == "X" || kind == "W") { #>
        "<#= kind.ToLowerInvariant() #>zr",
<# } #>
    ];

    private static readonly string[] Register<#= kind #>UpperNames = [
<# for(int i = 0; i < ((kind == "X" || kind == "W") ? 31 : (kind == "C" ? 16 : 32)); i++) { #>
        "<#= kind #><#= i #>",
<# } if (kind == "X" || kind == "W") { #>
        "<#= kind #>ZR",
<# } #>
    ];
<# if (kind == "V") { #>
<# foreach(var vector in vectors) { var vkind = vector.Name; #>
    /// <summary>
    /// Converts the <#= kind #> register to a string.
    /// </summary>
    public static string ToText(this Arm64Register<#= vkind #> register, bool upperCase = false) => upperCase ? RegisterVScalar<#= vkind #>UpperNames[ValidateRegisterIndex(register.Index)] : RegisterVScalar<#= vkind #>LowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterVScalar<#= vkind #>LowerNames = [
    <# for(int i = 0; i < 32; i++) { #>
    "<#= vkind.ToLowerInvariant() #><#= i #>",
    <# } #>
    ];

    private static readonly string[] RegisterVScalar<#= vkind #>UpperNames = [
    <# for(int i = 0; i < 32; i++) { #>
    "<#= vkind #><#= i #>",
    <# } #>
    ];

    /// <summary>
    /// Converts the <#= kind #> register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_<#= vkind #> register, bool upperCase = false) => upperCase ? RegisterV_<#= vkind #>UpperNames[ValidateRegisterIndex(register.Index)] : RegisterV_<#= vkind #>LowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV_<#= vkind #>LowerNames = [
    <# for(int i = 0; i < 32; i++) { #>
    "v<#= i #>.<#= vkind.ToLowerInvariant() #>",
    <# } #>
    ];

    private static readonly string[] RegisterV_<#= vkind #>UpperNames = [
    <# for(int i = 0; i < 32; i++) { #>
    "V<#= i #>.<#= vkind #>",
    <# } #>
    ];

<# foreach(var size in vector.Sizes) { #>

    /// <summary>
    /// Converts the <#= kind #> register to a string.
    /// </summary>
    public static string ToText(this Arm64RegisterV_<#= size #><#= vkind #> register, bool upperCase = false) => upperCase ? RegisterV<#= size #><#= vkind #>UpperNames[ValidateRegisterIndex(register.Index)] : RegisterV<#= size #><#= vkind #>LowerNames[ValidateRegisterIndex(register.Index)];

    private static readonly string[] RegisterV<#= size #><#= vkind #>LowerNames = [
    <# for(int i = 0; i < 32; i++) { #>
    "<#= kind.ToLowerInvariant() #><#= i #>.<#= size #><#= vkind.ToLowerInvariant() #>",
    <# } #>
    ];

    private static readonly string[] RegisterV<#= size #><#= vkind #>UpperNames = [
    <# for(int i = 0; i < 32; i++) { #>
    "<#= kind #><#= i #>.<#= size #><#= vkind #>",
    <# } #>
    ];
<# } // foreach size #>
<# } // foreach vector #>
<# } // if (kind == "V") #>
<# } // else #>
<# } // foreach kind #>
}
