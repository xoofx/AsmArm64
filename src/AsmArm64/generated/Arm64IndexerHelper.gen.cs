// Copyright (c) Alexandre Mutel. All rights reserved.
// Licensed under the BSD-Clause 2 license.
// See license.txt file in the project root for full license information.
// ------------------------------------------------------------------------------
// This code was generated by AsmArm64.CodeGen.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// ------------------------------------------------------------------------------
// ReSharper disable All
// ------------------------------------------------------------------------------


using System.Runtime.CompilerServices;

namespace AsmArm64;

/// <summary>
/// Decode Indexer class.
/// </summary>
static class Arm64IndexerHelper
{
    public static bool TryDecode(Arm64RawInstruction rawValue, byte mapIndex, out int index)
    {
        switch (mapIndex)
        {
            // FMOV_64vx_float2int           : FMOV        Xd, Vn.D[1] <- Operand: Vn.D[1]
            // FMOV_v64i_float2int           : FMOV        Vd.D[1], Xn <- Operand: Vd.D[1]
            case 1:
            {
                index = 1;
                return true;
            }
            // LD1_asisdlso_d1_1d            : LD1         {Vt.D}[index], [Xn|SP] <- Operand: {Vt.D}[index]
            case 2:
            {
                var bitValue = ((rawValue >> 30) & 0x1);
                index = (int)bitValue;
                return true;
            }
            // BFDOT_asimdelem_e             : BFDOT       Vd.Ta, Vn.Tb, Vm.2H[index] <- Operand: Vm.2H[index]
            case 3:
            {
                var bitValue = ((rawValue >> 21) & 0x1) | ((rawValue >> 10) & 0x2);
                index = (int)bitValue;
                return true;
            }
            // SM3TT1A_vvv4_crypto3_imm2     : SM3TT1A     Vd.4S, Vn.4S, Vm.S[imm2] <- Operand: Vm.S[imm2]
            case 4:
            {
                var bitValue = ((rawValue >> 12) & 0x3);
                index = (int)bitValue;
                return true;
            }
            // LUTI2_asimdtbl_l5             : LUTI2       Vd.16B, {Vn.16B}, Vm[index] <- Operand: Vm[index]
            case 5:
            {
                var bitValue = ((rawValue >> 13) & 0x3);
                index = (int)bitValue;
                return true;
            }
            // LD1_asisdlso_s1_1s            : LD1         {Vt.S}[index], [Xn|SP] <- Operand: {Vt.S}[index]
            case 6:
            {
                var bitValue = ((rawValue >> 12) & 0x1) | ((rawValue >> 29) & 0x2);
                index = (int)bitValue;
                return true;
            }
            // BFMLAL_asimdelem_f            : BFMLAL      btVd.4S, Vn.8H, Vm.H[index] <- Operand: Vm.H[index]
            case 7:
            {
                var bitValue = ((rawValue >> 20) & 0x3) | ((rawValue >> 9) & 0x4);
                index = (int)bitValue;
                return true;
            }
            // LUTI2_asimdtbl_l6             : LUTI2       Vd.8H, {Vn.8H}, Vm[index] <- Operand: Vm[index]
            case 8:
            {
                var bitValue = ((rawValue >> 12) & 0x7);
                index = (int)bitValue;
                return true;
            }
            // FMLA_asimdelem_r_sd           : FMLA        Vd.T, Vn.T, Vm.Ts[index] <- Operand: Vm.Ts[index]
            case 9:
            {
                var bitValue = ((rawValue >> 11) & 0x1) | ((rawValue >> 20) & 0x6);
                return TryDecodeFromBitValues(bitValue, 1, out index);
            }
            // FCMLA_advsimd_elt             : FCMLA       Vd.T, Vn.T, Vm.Ts[index], #rotate <- Operand: Vm.Ts[index]
            case 10:
            {
                var bitValue = ((rawValue >> 21) & 0x1) | ((rawValue >> 10) & 0x2) | ((rawValue >> 20) & 0xC);
                return TryDecodeFromBitValues(bitValue, 2, out index);
            }
            // LD1_asisdlso_b1_1b            : LD1         {Vt.B}[index], [Xn|SP] <- Operand: {Vt.B}[index]
            case 11:
            {
                var bitValue = ((rawValue >> 10) & 0x7) | ((rawValue >> 27) & 0x8);
                index = (int)bitValue;
                return true;
            }
            // UMOV_asimdins_x_x             : UMOV        Xd, Vn.D[index] <- Operand: Vn.D[index]
            case 12:
            {
                var bitValue = ((rawValue >> 16) & 0x1F);
                index = (int)bitValue;
                return true;
            }
            // DUP_asimdins_dv_v             : DUP         Vd.T, Vn.Ts[index] <- Operand: Vn.Ts[index]
            case 13:
            {
                var bitValue = ((rawValue >> 16) & 0x1F);
                return TryDecodeFromBitValues(bitValue, 4, out index);
            }
            // SMOV_asimdins_x_x             : SMOV        Xd, Vn.Ts[index] <- Operand: Vn.Ts[index]
            case 14:
            {
                var bitValue = ((rawValue >> 16) & 0x1F);
                return TryDecodeFromBitValues(bitValue, 5, out index);
            }
            // SMOV_asimdins_w_w             : SMOV        Wd, Vn.Ts[index] <- Operand: Vn.Ts[index]
            case 15:
            {
                var bitValue = ((rawValue >> 16) & 0x1F);
                return TryDecodeFromBitValues(bitValue, 6, out index);
            }
            // MLA_asimdelem_r               : MLA         Vd.T, Vn.T, Vm.Ts[index] <- Operand: Vm.Ts[index]
            case 16:
            {
                var bitValue = ((rawValue >> 20) & 0x3) | ((rawValue >> 9) & 0x4) | ((rawValue >> 19) & 0x18);
                return TryDecodeFromBitValues(bitValue, 3, out index);
            }
            // FMLALB_asimdelem_h            : FMLALB      Vd.8H, Vn.16B, Vm.B[index] <- Operand: Vm.B[index]
            case 17:
            {
                var bitValue = ((rawValue >> 16) & 0x3F) | ((rawValue >> 5) & 0x40);
                index = (int)bitValue;
                return true;
            }
            // INS_asimdins_iv_v             : INS         Vd.Ts[index1], Vn.Ts[index2] <- Operand: Vn.Ts[index2]
            case 18:
            {
                var bitValue = ((rawValue >> 11) & 0xF) | ((rawValue >> 12) & 0x1F0);
                return TryDecodeFromBitValues(bitValue, 7, out index);
            }
        }
        
        index = default;
        return false;
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryDecodeFromBitValues(uint bitValue, byte selectorIndex, out int index)
    {
        switch (selectorIndex)
        {
            case 1:
            {
                var bitsToTest = ((bitValue >> 1) & 0x3);
                if (bitsToTest == 2)
                {
                    var extractedValue = (bitValue & 0x1);
                    index = (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0x2) == 0)
                {
                    var extractedValue = ((bitValue >> 1) & 0x1) | (bitValue & 0x2);
                    index = (int)extractedValue;
                    return true;
                }
                break;
            }
            case 2:
            {
                var bitsToTest = ((bitValue >> 2) & 0x3);
                switch (bitsToTest)
                {
                    case 1:
                    {
                        var extractedValue = ((bitValue >> 1) & 0x3);
                        index = (int)extractedValue;
                        return true;
                    }
                    case 2:
                    {
                        var extractedValue = ((bitValue >> 1) & 0x1);
                        index = (int)extractedValue;
                        return true;
                    }
                }
                break;
            }
            case 3:
            {
                var bitsToTest = ((bitValue >> 3) & 0x3);
                switch (bitsToTest)
                {
                    case 1:
                    {
                        var extractedValue = ((bitValue >> 2) & 0x7);
                        index = (int)extractedValue;
                        return true;
                    }
                    case 2:
                    {
                        var extractedValue = ((bitValue >> 2) & 0x3);
                        index = (int)extractedValue;
                        return true;
                    }
                }
                break;
            }
            case 4:
            {
                var bitsToTest = (bitValue & 0x1F);
                if ((bitsToTest & 0xf) == 8)
                {
                    var extractedValue = ((bitValue >> 4) & 0x1);
                    index = (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0x7) == 4)
                {
                    var extractedValue = ((bitValue >> 3) & 0x3);
                    index = (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0x3) == 2)
                {
                    var extractedValue = ((bitValue >> 2) & 0x1) | ((bitValue >> 3) & 0x2);
                    index = (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0x1) == 1)
                {
                    var extractedValue = ((bitValue >> 1) & 0x1) | ((bitValue >> 3) & 0x2);
                    index = (int)extractedValue;
                    return true;
                }
                break;
            }
            case 5:
            {
                var bitsToTest = (bitValue & 0x1F);
                if ((bitsToTest & 0x7) == 4)
                {
                    var extractedValue = ((bitValue >> 3) & 0x3);
                    index = (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0x3) == 2)
                {
                    var extractedValue = ((bitValue >> 2) & 0x1) | ((bitValue >> 3) & 0x2);
                    index = (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0x1) == 1)
                {
                    var extractedValue = ((bitValue >> 1) & 0x1) | ((bitValue >> 3) & 0x2);
                    index = (int)extractedValue;
                    return true;
                }
                break;
            }
            case 6:
            {
                var bitsToTest = (bitValue & 0x1F);
                if ((bitsToTest & 0x3) == 2)
                {
                    var extractedValue = ((bitValue >> 2) & 0x1) | ((bitValue >> 3) & 0x2);
                    index = (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0x1) == 1)
                {
                    var extractedValue = ((bitValue >> 1) & 0x1) | ((bitValue >> 3) & 0x2);
                    index = (int)extractedValue;
                    return true;
                }
                break;
            }
            case 7:
            {
                var bitsToTest = ((bitValue >> 4) & 0x1F);
                if ((bitsToTest & 0xf) == 8)
                {
                    var extractedValue = ((bitValue >> 3) & 0x1);
                    index = (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0x7) == 4)
                {
                    var extractedValue = ((bitValue >> 2) & 0x3);
                    index = (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0x3) == 2)
                {
                    var extractedValue = ((bitValue >> 1) & 0x1) | ((bitValue >> 2) & 0x2);
                    index = (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0x1) == 1)
                {
                    var extractedValue = (bitValue & 0xF);
                    index = (int)extractedValue;
                    return true;
                }
                break;
            }
        }
        
        index = default;
        return false;
    }
}
