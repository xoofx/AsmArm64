// Copyright (c) Alexandre Mutel. All rights reserved.
// Licensed under the BSD-Clause 2 license.
// See license.txt file in the project root for full license information.
// ------------------------------------------------------------------------------
// This code was generated by AsmArm64.CodeGen.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// ------------------------------------------------------------------------------
// ReSharper disable All
// ------------------------------------------------------------------------------


using System.Runtime.CompilerServices;

namespace AsmArm64;

/// <summary>
/// Decode Immediate class.
/// </summary>
static class Arm64ImmediateHelper
{
    public static bool TryDecode(Arm64RawInstruction rawValue, byte mapIndex, out int imm)
    {
        switch (mapIndex)
        {
            case 1:
            {
                var bitValue = ((rawValue >> 12) & 0x1);
                return TryDecodeFromBitValues(bitValue, 1, out imm);
            }
            case 2:
            {
                var bitValue = ((rawValue >> 11) & 0x3);
                return TryDecodeFromBitValues(bitValue, 2, out imm);
            }
            case 3:
            {
                var bitValue = ((rawValue >> 13) & 0x3);
                return TryDecodeFromBitValues(bitValue, 2, out imm);
            }
            case 4:
            {
                var bitValue = ((rawValue >> 22) & 0x3);
                return TryDecodeFromBitValues(bitValue, 3, out imm);
            }
            case 5:
            {
                var bitValue = ((rawValue >> 11) & 0xF) | ((rawValue >> 26) & 0x10);
                return TryDecodeFromBitValues(bitValue, 4, out imm);
            }
            case 6:
            {
                var bitValue = ((rawValue >> 16) & 0x7F);
                return TryDecodeFromBitValues(bitValue, 5, out imm);
            }
            case 7:
            {
                var bitValue = ((rawValue >> 16) & 0x7F);
                return TryDecodeFromBitValues(bitValue, 6, out imm);
            }
            case 8:
            {
                var bitValue = ((rawValue >> 16) & 0x7F);
                return TryDecodeFromBitValues(bitValue, 7, out imm);
            }
            case 9:
            {
                var bitValue = ((rawValue >> 16) & 0x7F);
                return TryDecodeFromBitValues(bitValue, 8, out imm);
            }
            case 10:
            {
                var bitValue = ((rawValue >> 16) & 0x7F);
                return TryDecodeFromBitValues(bitValue, 9, out imm);
            }
        }
        
        imm = default;
        return false;
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryDecodeFromBitValues(uint bitValue, byte selectorIndex, out int imm)
    {
        switch (selectorIndex)
        {
            case 1:
            {
                var bitsToTest = (bitValue & 0x1);
                switch (bitsToTest)
                {
                    case 0:
                    {
                        imm = (int)90;
                        return true;
                    }
                    case 1:
                    {
                        imm = (int)270;
                        return true;
                    }
                }
                break;
            }
            case 2:
            {
                var bitsToTest = (bitValue & 0x3);
                switch (bitsToTest)
                {
                    case 0:
                    {
                        imm = (int)0;
                        return true;
                    }
                    case 1:
                    {
                        imm = (int)90;
                        return true;
                    }
                    case 2:
                    {
                        imm = (int)180;
                        return true;
                    }
                    case 3:
                    {
                        imm = (int)270;
                        return true;
                    }
                }
                break;
            }
            case 3:
            {
                var bitsToTest = (bitValue & 0x3);
                switch (bitsToTest)
                {
                    case 0:
                    {
                        imm = (int)8;
                        return true;
                    }
                    case 1:
                    {
                        imm = (int)16;
                        return true;
                    }
                    case 2:
                    {
                        imm = (int)32;
                        return true;
                    }
                }
                break;
            }
            case 4:
            {
                var bitsToTest = ((bitValue >> 3) & 0x3);
                if (bitsToTest == 0)
                {
                    var extractedValue = (bitValue & 0x1) | ((bitValue >> 1) & 0x2);
                    imm = (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0x2) == 2)
                {
                    var extractedValue = (bitValue & 0xF);
                    imm = (int)extractedValue;
                    return true;
                }
                break;
            }
            case 5:
            {
                var bitsToTest = ((bitValue >> 3) & 0xF);
                if (bitsToTest == 1)
                {
                    var extractedValue = (bitValue & 0x7F);
                    imm = 16 - (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0xe) == 2)
                {
                    var extractedValue = (bitValue & 0x7F);
                    imm = 32 - (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0xc) == 4)
                {
                    var extractedValue = (bitValue & 0x7F);
                    imm = 64 - (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0x8) == 8)
                {
                    var extractedValue = (bitValue & 0x7F);
                    imm = 128 - (int)extractedValue;
                    return true;
                }
                break;
            }
            case 6:
            {
                var bitsToTest = ((bitValue >> 3) & 0xF);
                if (bitsToTest == 1)
                {
                    var extractedValue = (bitValue & 0x7F);
                    imm = 16 - (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0xe) == 2)
                {
                    var extractedValue = (bitValue & 0x7F);
                    imm = 32 - (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0xc) == 4)
                {
                    var extractedValue = (bitValue & 0x7F);
                    imm = 64 - (int)extractedValue;
                    return true;
                }
                break;
            }
            case 7:
            {
                var bitsToTest = ((bitValue >> 3) & 0xF);
                if (bitsToTest == 1)
                {
                    var extractedValue = (bitValue & 0x7F);
                    imm = (int)extractedValue - 8;
                    return true;
                }
                if ((bitsToTest & 0xe) == 2)
                {
                    var extractedValue = (bitValue & 0x7F);
                    imm = (int)extractedValue - 16;
                    return true;
                }
                if ((bitsToTest & 0xc) == 4)
                {
                    var extractedValue = (bitValue & 0x7F);
                    imm = (int)extractedValue - 32;
                    return true;
                }
                if ((bitsToTest & 0x8) == 8)
                {
                    var extractedValue = (bitValue & 0x7F);
                    imm = (int)extractedValue - 64;
                    return true;
                }
                break;
            }
            case 8:
            {
                var bitsToTest = ((bitValue >> 3) & 0xF);
                if (bitsToTest == 1)
                {
                    var extractedValue = (bitValue & 0x7F);
                    imm = (int)extractedValue - 8;
                    return true;
                }
                if ((bitsToTest & 0xe) == 2)
                {
                    var extractedValue = (bitValue & 0x7F);
                    imm = (int)extractedValue - 16;
                    return true;
                }
                if ((bitsToTest & 0xc) == 4)
                {
                    var extractedValue = (bitValue & 0x7F);
                    imm = (int)extractedValue - 32;
                    return true;
                }
                break;
            }
            case 9:
            {
                var bitsToTest = ((bitValue >> 3) & 0xF);
                if ((bitsToTest & 0xe) == 2)
                {
                    var extractedValue = (bitValue & 0x7F);
                    imm = 32 - (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0xc) == 4)
                {
                    var extractedValue = (bitValue & 0x7F);
                    imm = 64 - (int)extractedValue;
                    return true;
                }
                if ((bitsToTest & 0x8) == 8)
                {
                    var extractedValue = (bitValue & 0x7F);
                    imm = 128 - (int)extractedValue;
                    return true;
                }
                break;
            }
        }
        
        imm = default;
        return false;
    }
}
