// Copyright (c) Alexandre Mutel. All rights reserved.
// Licensed under the BSD-Clause 2 license.
// See license.txt file in the project root for full license information.
// ------------------------------------------------------------------------------
// This code was generated by AsmArm64.CodeGen.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// ------------------------------------------------------------------------------
// ReSharper disable All
// ------------------------------------------------------------------------------
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
using System.Runtime.CompilerServices;
namespace AsmArm64;
partial class Arm64Assembler
{
    /// <summary>
    /// Associate physical address space.
    /// </summary>
    /// <remarks><code>APAS Xt</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.APAS_sys_cr_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void APAS(Arm64RegisterX Xt)
         => AddInstruction(Arm64InstructionFactory.APAS(Xt));
    /// <summary>
    /// Address translate.
    /// </summary>
    /// <remarks><code>AT at_op, Xt</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.AT_sys_cr_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AT(Arm64SystemRegister at_op, Arm64RegisterX Xt)
         => AddInstruction(Arm64InstructionFactory.AT(at_op, Xt));
    /// <summary>
    /// Authenticate instruction address, using key A.
    /// </summary>
    /// <remarks><code>AUTIA1716 </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.AUTIA1716_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AUTIA1716()
         => AddInstruction(Arm64InstructionFactory.AUTIA1716());
    /// <summary>
    /// Authenticate instruction address, using key A.
    /// </summary>
    /// <remarks><code>AUTIASP </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.AUTIASP_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AUTIASP()
         => AddInstruction(Arm64InstructionFactory.AUTIASP());
    /// <summary>
    /// Authenticate instruction address, using key A.
    /// </summary>
    /// <remarks><code>AUTIAZ </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.AUTIAZ_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AUTIAZ()
         => AddInstruction(Arm64InstructionFactory.AUTIAZ());
    /// <summary>
    /// Authenticate instruction address, using key B.
    /// </summary>
    /// <remarks><code>AUTIB1716 </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.AUTIB1716_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AUTIB1716()
         => AddInstruction(Arm64InstructionFactory.AUTIB1716());
    /// <summary>
    /// Authenticate instruction address, using key B.
    /// </summary>
    /// <remarks><code>AUTIBSP </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.AUTIBSP_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AUTIBSP()
         => AddInstruction(Arm64InstructionFactory.AUTIBSP());
    /// <summary>
    /// Authenticate instruction address, using key B.
    /// </summary>
    /// <remarks><code>AUTIBZ </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.AUTIBZ_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AUTIBZ()
         => AddInstruction(Arm64InstructionFactory.AUTIBZ());
    /// <summary>
    /// Convert floating-point condition flags from Arm to external format.
    /// </summary>
    /// <remarks><code>AXFLAG </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.AXFLAG_m_pstate), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AXFLAG()
         => AddInstruction(Arm64InstructionFactory.AXFLAG());
    /// <summary>
    /// Branch record buffer.
    /// </summary>
    /// <remarks><code>BRB brb_op</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.BRB_sys_cr_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void BRB(Arm64SystemRegister brb_op)
         => AddInstruction(Arm64InstructionFactory.BRB(brb_op));
    /// <summary>
    /// Breakpoint instruction.
    /// </summary>
    /// <remarks><code>BRK #imm</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.BRK_ex_exception), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void BRK(ushort imm)
         => AddInstruction(Arm64InstructionFactory.BRK(imm));
    /// <summary>
    /// Branch target identification.
    /// </summary>
    /// <remarks><code>BTI {targets}</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.BTI_hb_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void BTI(Arm64BranchTargetIdentificationKind targets = default)
         => AddInstruction(Arm64InstructionFactory.BTI(targets));
    /// <summary>
    /// Invert carry flag.
    /// </summary>
    /// <remarks><code>CFINV </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.CFINV_m_pstate), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void CFINV()
         => AddInstruction(Arm64InstructionFactory.CFINV());
    /// <summary>
    /// Control flow prediction restriction by context.
    /// </summary>
    /// <remarks><code>CFP RCTX, Xt</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.CFP_sys_cr_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void CFP(Arm64RestrictionByContextKind RCTX, Arm64RegisterX Xt)
         => AddInstruction(Arm64InstructionFactory.CFP(RCTX, Xt));
    /// <summary>
    /// Check feature status.
    /// </summary>
    /// <remarks><code>CHKFEAT X16</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.CHKFEAT_hf_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void CHKFEAT(Arm64RegisterX X16)
         => AddInstruction(Arm64InstructionFactory.CHKFEAT(X16));
    /// <summary>
    /// Clear branch history.
    /// </summary>
    /// <remarks><code>CLRBHB </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.CLRBHB_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void CLRBHB()
         => AddInstruction(Arm64InstructionFactory.CLRBHB());
    /// <summary>
    /// Clear exclusive.
    /// </summary>
    /// <remarks><code>CLREX {#imm}</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.CLREX_bn_barriers), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void CLREX(byte imm = default)
         => AddInstruction(Arm64InstructionFactory.CLREX(imm));
    /// <summary>
    /// Clear other speculative prediction restriction by context.
    /// </summary>
    /// <remarks><code>COSP RCTX, Xt</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.COSP_sys_cr_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void COSP(Arm64RestrictionByContextKind RCTX, Arm64RegisterX Xt)
         => AddInstruction(Arm64InstructionFactory.COSP(RCTX, Xt));
    /// <summary>
    /// Cache prefetch prediction restriction by context.
    /// </summary>
    /// <remarks><code>CPP RCTX, Xt</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.CPP_sys_cr_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void CPP(Arm64RestrictionByContextKind RCTX, Arm64RegisterX Xt)
         => AddInstruction(Arm64InstructionFactory.CPP(RCTX, Xt));
    /// <summary>
    /// Consumption of speculative data barrier.
    /// </summary>
    /// <remarks><code>CSDB </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.CSDB_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void CSDB()
         => AddInstruction(Arm64InstructionFactory.CSDB());
    /// <summary>
    /// Data cache operation.
    /// </summary>
    /// <remarks><code>DC dc_op, Xt</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.DC_sys_cr_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void DC(Arm64SystemRegister dc_op, Arm64RegisterX Xt)
         => AddInstruction(Arm64InstructionFactory.DC(dc_op, Xt));
    /// <summary>
    /// Debug change PE state to EL1.
    /// </summary>
    /// <remarks><code>DCPS1 {#imm}</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.DCPS1_dc_exception), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void DCPS1(ushort imm = default)
         => AddInstruction(Arm64InstructionFactory.DCPS1(imm));
    /// <summary>
    /// Debug change PE state to EL2.
    /// </summary>
    /// <remarks><code>DCPS2 {#imm}</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.DCPS2_dc_exception), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void DCPS2(ushort imm = default)
         => AddInstruction(Arm64InstructionFactory.DCPS2(imm));
    /// <summary>
    /// Debug change PE state to EL3.
    /// </summary>
    /// <remarks><code>DCPS3 {#imm}</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.DCPS3_dc_exception), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void DCPS3(ushort imm = default)
         => AddInstruction(Arm64InstructionFactory.DCPS3(imm));
    /// <summary>
    /// Data gathering hint.
    /// </summary>
    /// <remarks><code>DGH </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.DGH_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void DGH()
         => AddInstruction(Arm64InstructionFactory.DGH());
    /// <summary>
    /// Data memory barrier.
    /// </summary>
    /// <remarks><code>DMB (option|#imm)</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.DMB_bo_barriers), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void DMB(Arm64BarrierOperationLimitKind option)
         => AddInstruction(Arm64InstructionFactory.DMB(option));
    /// <summary>
    /// Debug restore PE state.
    /// </summary>
    /// <remarks><code>DRPS </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.DRPS_64e_branch_reg), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void DRPS()
         => AddInstruction(Arm64InstructionFactory.DRPS());
    /// <summary>
    /// Data synchronization barrier.
    /// </summary>
    /// <remarks><code>DSB (option|#imm)</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.DSB_bo_barriers), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void DSB(Arm64BarrierOperationLimitKind option)
         => AddInstruction(Arm64InstructionFactory.DSB(option));
    /// <summary>
    /// Data synchronization barrier.
    /// </summary>
    /// <remarks><code>DSB optionnXS</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.DSB_bon_barriers), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void DSB(Arm64DataSynchronizationKind option)
         => AddInstruction(Arm64InstructionFactory.DSB(option));
    /// <summary>
    /// Data value prediction restriction by context.
    /// </summary>
    /// <remarks><code>DVP RCTX, Xt</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.DVP_sys_cr_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void DVP(Arm64RestrictionByContextKind RCTX, Arm64RegisterX Xt)
         => AddInstruction(Arm64InstructionFactory.DVP(RCTX, Xt));
    /// <summary>
    /// Exception return.
    /// </summary>
    /// <remarks><code>ERET </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.ERET_64e_branch_reg), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ERET()
         => AddInstruction(Arm64InstructionFactory.ERET());
    /// <summary>
    /// Error synchronization barrier.
    /// </summary>
    /// <remarks><code>ESB </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.ESB_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ESB()
         => AddInstruction(Arm64InstructionFactory.ESB());
    /// <summary>
    /// Guarded Control Stack barrier.
    /// </summary>
    /// <remarks><code>GCSB DSYNC</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.GCSB_hd_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void GCSB(Arm64DataSyncKind DSYNC)
         => AddInstruction(Arm64InstructionFactory.GCSB(DSYNC));
    /// <summary>
    /// Guarded Control Stack pop and compare exception return record.
    /// </summary>
    /// <remarks><code>GCSPOPCX </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.GCSPOPCX_sys_cr_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void GCSPOPCX()
         => AddInstruction(Arm64InstructionFactory.GCSPOPCX());
    /// <summary>
    /// Guarded Control Stack pop.
    /// </summary>
    /// <remarks><code>GCSPOPM {Xt}</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.GCSPOPM_sysl_rc_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void GCSPOPM(Arm64RegisterX Xt = default)
         => AddInstruction(Arm64InstructionFactory.GCSPOPM(Xt));
    /// <summary>
    /// Guarded Control Stack pop exception return record.
    /// </summary>
    /// <remarks><code>GCSPOPX </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.GCSPOPX_sys_cr_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void GCSPOPX()
         => AddInstruction(Arm64InstructionFactory.GCSPOPX());
    /// <summary>
    /// Guarded Control Stack push.
    /// </summary>
    /// <remarks><code>GCSPUSHM Xt</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.GCSPUSHM_sys_cr_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void GCSPUSHM(Arm64RegisterX Xt)
         => AddInstruction(Arm64InstructionFactory.GCSPUSHM(Xt));
    /// <summary>
    /// Guarded Control Stack push exception return record.
    /// </summary>
    /// <remarks><code>GCSPUSHX </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.GCSPUSHX_sys_cr_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void GCSPUSHX()
         => AddInstruction(Arm64InstructionFactory.GCSPUSHX());
    /// <summary>
    /// Guarded Control Stack switch stack 1.
    /// </summary>
    /// <remarks><code>GCSSS1 Xt</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.GCSSS1_sys_cr_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void GCSSS1(Arm64RegisterX Xt)
         => AddInstruction(Arm64InstructionFactory.GCSSS1(Xt));
    /// <summary>
    /// Guarded Control Stack switch stack 2.
    /// </summary>
    /// <remarks><code>GCSSS2 Xt</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.GCSSS2_sysl_rc_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void GCSSS2(Arm64RegisterX Xt)
         => AddInstruction(Arm64InstructionFactory.GCSSS2(Xt));
    /// <summary>
    /// Hint instruction.
    /// </summary>
    /// <remarks><code>HINT #imm</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.HINT_hm_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void HINT(byte imm)
         => AddInstruction(Arm64InstructionFactory.HINT(imm));
    /// <summary>
    /// Halt instruction.
    /// </summary>
    /// <remarks><code>HLT #imm</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.HLT_ex_exception), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void HLT(ushort imm)
         => AddInstruction(Arm64InstructionFactory.HLT(imm));
    /// <summary>
    /// Hypervisor call.
    /// </summary>
    /// <remarks><code>HVC #imm</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.HVC_ex_exception), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void HVC(ushort imm)
         => AddInstruction(Arm64InstructionFactory.HVC(imm));
    /// <summary>
    /// Instruction cache operation.
    /// </summary>
    /// <remarks><code>IC ic_op {, Xt}</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.IC_sys_cr_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void IC(Arm64SystemRegister ic_op, Arm64RegisterX Xt = default)
         => AddInstruction(Arm64InstructionFactory.IC(ic_op, Xt));
    /// <summary>
    /// Instruction synchronization barrier.
    /// </summary>
    /// <remarks><code>ISB {option, #imm}</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.ISB_bi_barriers), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ISB(byte option = default)
         => AddInstruction(Arm64InstructionFactory.ISB(option));
    /// <summary>
    /// Move System register to two adjacent general-purpose registers.
    /// </summary>
    /// <remarks><code>MRRS Xt, Xt+1, (systemreg|Sop0_op1_Cn_Cm_op2)</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.MRRS_rs_systemmovepr), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void MRRS(Arm64RegisterX Xt, Arm64RegisterX Xt_1, Arm64SystemRegister systemreg)
         => AddInstruction(Arm64InstructionFactory.MRRS(Xt, Xt_1, systemreg));
    /// <summary>
    /// Move System register to general-purpose register.
    /// </summary>
    /// <remarks><code>MRS Xt, (systemreg|Sop0_op1_Cn_Cm_op2)</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.MRS_rs_systemmove), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void MRS(Arm64RegisterX Xt, Arm64SystemRegister systemreg)
         => AddInstruction(Arm64InstructionFactory.MRS(Xt, systemreg));
    /// <summary>
    /// Move immediate value to special register.
    /// </summary>
    /// <remarks><code>MSR pstatefield, #imm</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.MSR_si_pstate), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void MSR(Arm64ProcessStateField pstatefield, uint imm)
         => AddInstruction(Arm64InstructionFactory.MSR(pstatefield, imm));
    /// <summary>
    /// Move general-purpose register to System register.
    /// </summary>
    /// <remarks><code>MSR (systemreg|Sop0_op1_Cn_Cm_op2), Xt</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.MSR_sr_systemmove), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void MSR(Arm64SystemRegister systemreg, Arm64RegisterX Xt)
         => AddInstruction(Arm64InstructionFactory.MSR(systemreg, Xt));
    /// <summary>
    /// Move two adjacent general-purpose registers to System register.
    /// </summary>
    /// <remarks><code>MSRR (systemreg|Sop0_op1_Cn_Cm_op2), Xt, Xt+1</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.MSRR_sr_systemmovepr), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void MSRR(Arm64SystemRegister systemreg, Arm64RegisterX Xt, Arm64RegisterX Xt_1)
         => AddInstruction(Arm64InstructionFactory.MSRR(systemreg, Xt, Xt_1));
    /// <summary>
    /// No operation.
    /// </summary>
    /// <remarks><code>NOP </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.NOP_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void NOP()
         => AddInstruction(Arm64InstructionFactory.NOP());
    /// <summary>
    /// Pointer Authentication Code for instruction address, using key A.
    /// </summary>
    /// <remarks><code>PACIA1716 </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.PACIA1716_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void PACIA1716()
         => AddInstruction(Arm64InstructionFactory.PACIA1716());
    /// <summary>
    /// Pointer Authentication Code for instruction address, using key A.
    /// </summary>
    /// <remarks><code>PACIASP </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.PACIASP_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void PACIASP()
         => AddInstruction(Arm64InstructionFactory.PACIASP());
    /// <summary>
    /// Pointer Authentication Code for instruction address, using key A.
    /// </summary>
    /// <remarks><code>PACIAZ </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.PACIAZ_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void PACIAZ()
         => AddInstruction(Arm64InstructionFactory.PACIAZ());
    /// <summary>
    /// Pointer Authentication Code for instruction address, using key B.
    /// </summary>
    /// <remarks><code>PACIB1716 </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.PACIB1716_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void PACIB1716()
         => AddInstruction(Arm64InstructionFactory.PACIB1716());
    /// <summary>
    /// Pointer Authentication Code for instruction address, using key B.
    /// </summary>
    /// <remarks><code>PACIBSP </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.PACIBSP_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void PACIBSP()
         => AddInstruction(Arm64InstructionFactory.PACIBSP());
    /// <summary>
    /// Pointer Authentication Code for instruction address, using key B.
    /// </summary>
    /// <remarks><code>PACIBZ </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.PACIBZ_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void PACIBZ()
         => AddInstruction(Arm64InstructionFactory.PACIBZ());
    /// <summary>
    /// Pointer authentication modifier.
    /// </summary>
    /// <remarks><code>PACM </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.PACM_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void PACM()
         => AddInstruction(Arm64InstructionFactory.PACM());
    /// <summary>
    /// Profiling synchronization barrier.
    /// </summary>
    /// <remarks><code>PSB CSYNC</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.PSB_hc_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void PSB(Arm64CodeSyncKind CSYNC)
         => AddInstruction(Arm64InstructionFactory.PSB(CSYNC));
    /// <summary>
    /// Physical speculative store bypass barrier.
    /// </summary>
    /// <remarks><code>PSSBB </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.PSSBB_dsb_bo_barriers), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void PSSBB()
         => AddInstruction(Arm64InstructionFactory.PSSBB());
    /// <summary>
    /// Speculation barrier.
    /// </summary>
    /// <remarks><code>SB </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.SB_only_barriers), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SB()
         => AddInstruction(Arm64InstructionFactory.SB());
    /// <summary>
    /// Send event.
    /// </summary>
    /// <remarks><code>SEV </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.SEV_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SEV()
         => AddInstruction(Arm64InstructionFactory.SEV());
    /// <summary>
    /// Send event local.
    /// </summary>
    /// <remarks><code>SEVL </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.SEVL_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SEVL()
         => AddInstruction(Arm64InstructionFactory.SEVL());
    /// <summary>
    /// Secure monitor call.
    /// </summary>
    /// <remarks><code>SMC #imm</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.SMC_ex_exception), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SMC(ushort imm)
         => AddInstruction(Arm64InstructionFactory.SMC(imm));
    /// <summary>
    /// Enables access to Streaming SVE mode and SME architectural state.
    /// </summary>
    /// <remarks><code>SMSTART {option}</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.SMSTART_msr_si_pstate), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SMSTART(Arm64StreamingMode option = Arm64StreamingMode.Absent)
         => AddInstruction(Arm64InstructionFactory.SMSTART(option));
    /// <summary>
    /// Disables access to Streaming SVE mode and SME architectural state.
    /// </summary>
    /// <remarks><code>SMSTOP {option}</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.SMSTOP_msr_si_pstate), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SMSTOP(Arm64StreamingMode option = Arm64StreamingMode.Absent)
         => AddInstruction(Arm64InstructionFactory.SMSTOP(option));
    /// <summary>
    /// Speculative store bypass barrier.
    /// </summary>
    /// <remarks><code>SSBB </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.SSBB_dsb_bo_barriers), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SSBB()
         => AddInstruction(Arm64InstructionFactory.SSBB());
    /// <summary>
    /// Store shared hint.
    /// </summary>
    /// <remarks><code>STSHH policy</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.STSHH_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void STSHH(Arm64StoredSharedHintPolicyKind policy)
         => AddInstruction(Arm64InstructionFactory.STSHH(policy));
    /// <summary>
    /// Supervisor call.
    /// </summary>
    /// <remarks><code>SVC #imm</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.SVC_ex_exception), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SVC(ushort imm)
         => AddInstruction(Arm64InstructionFactory.SVC(imm));
    /// <summary>
    /// System instruction.
    /// </summary>
    /// <remarks><code>SYS #op1, Cn, Cm, #op2 {, Xt}</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.SYS_cr_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SYS(byte op1, Arm64RegisterC Cn, Arm64RegisterC Cm, byte op2, Arm64RegisterX Xt = default)
         => AddInstruction(Arm64InstructionFactory.SYS(op1, Cn, Cm, op2, Xt));
    /// <summary>
    /// System instruction with result.
    /// </summary>
    /// <remarks><code>SYSL Xt, #op1, Cn, Cm, #op2</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.SYSL_rc_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SYSL(Arm64RegisterX Xt, byte op1, Arm64RegisterC Cn, Arm64RegisterC Cm, byte op2)
         => AddInstruction(Arm64InstructionFactory.SYSL(Xt, op1, Cn, Cm, op2));
    /// <summary>
    /// 128-bit system instruction.
    /// </summary>
    /// <remarks><code>SYSP #op1, Cn, Cm, #op2 {, Xt1, Xt2}</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.SYSP_cr_syspairinstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SYSP(byte op1, Arm64RegisterC Cn, Arm64RegisterC Cm, byte op2, Arm64RegisterX Xt1 = default)
         => AddInstruction(Arm64InstructionFactory.SYSP(op1, Cn, Cm, op2, Xt1));
    /// <summary>
    /// Cancel current transaction.
    /// </summary>
    /// <remarks><code>TCANCEL #imm</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.TCANCEL_ex_exception), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void TCANCEL(ushort imm)
         => AddInstruction(Arm64InstructionFactory.TCANCEL(imm));
    /// <summary>
    /// Commit current transaction.
    /// </summary>
    /// <remarks><code>TCOMMIT </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.TCOMMIT_only_barriers), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void TCOMMIT()
         => AddInstruction(Arm64InstructionFactory.TCOMMIT());
    /// <summary>
    /// TLB invalidate operation.
    /// </summary>
    /// <remarks><code>TLBI tlbi_op {, Xt}</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.TLBI_sys_cr_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void TLBI(Arm64SystemRegister tlbi_op, Arm64RegisterX Xt = default)
         => AddInstruction(Arm64InstructionFactory.TLBI(tlbi_op, Xt));
    /// <summary>
    /// TLB invalidate pair operation.
    /// </summary>
    /// <remarks><code>TLBIP tlbip_op {, Xt1, Xt2}</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.TLBIP_sysp_cr_syspairinstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void TLBIP(Arm64SystemRegister tlbip_op, Arm64RegisterX Xt1 = default)
         => AddInstruction(Arm64InstructionFactory.TLBIP(tlbip_op, Xt1));
    /// <summary>
    /// Trace instrumentation.
    /// </summary>
    /// <remarks><code>TRCIT Xt</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.TRCIT_sys_cr_systeminstrs), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void TRCIT(Arm64RegisterX Xt)
         => AddInstruction(Arm64InstructionFactory.TRCIT(Xt));
    /// <summary>
    /// Trace synchronization barrier.
    /// </summary>
    /// <remarks><code>TSB CSYNC</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.TSB_hc_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void TSB(Arm64CodeSyncKind CSYNC)
         => AddInstruction(Arm64InstructionFactory.TSB(CSYNC));
    /// <summary>
    /// Start transaction.
    /// </summary>
    /// <remarks><code>TSTART Xt</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.TSTART_br_systemresult), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void TSTART(Arm64RegisterX Xt)
         => AddInstruction(Arm64InstructionFactory.TSTART(Xt));
    /// <summary>
    /// Test transaction state.
    /// </summary>
    /// <remarks><code>TTEST Xt</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.TTEST_br_systemresult), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void TTEST(Arm64RegisterX Xt)
         => AddInstruction(Arm64InstructionFactory.TTEST(Xt));
    /// <summary>
    /// Wait for event.
    /// </summary>
    /// <remarks><code>WFE </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.WFE_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WFE()
         => AddInstruction(Arm64InstructionFactory.WFE());
    /// <summary>
    /// Wait for event with timeout.
    /// </summary>
    /// <remarks><code>WFET Xt</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.WFET_only_systeminstrswithreg), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WFET(Arm64RegisterX Xt)
         => AddInstruction(Arm64InstructionFactory.WFET(Xt));
    /// <summary>
    /// Wait for interrupt.
    /// </summary>
    /// <remarks><code>WFI </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.WFI_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WFI()
         => AddInstruction(Arm64InstructionFactory.WFI());
    /// <summary>
    /// Wait for interrupt with timeout.
    /// </summary>
    /// <remarks><code>WFIT Xt</code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.WFIT_only_systeminstrswithreg), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void WFIT(Arm64RegisterX Xt)
         => AddInstruction(Arm64InstructionFactory.WFIT(Xt));
    /// <summary>
    /// Convert floating-point condition flags from external format to Arm format.
    /// </summary>
    /// <remarks><code>XAFLAG </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.XAFLAG_m_pstate), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void XAFLAG()
         => AddInstruction(Arm64InstructionFactory.XAFLAG());
    /// <summary>
    /// Strip Pointer Authentication Code.
    /// </summary>
    /// <remarks><code>XPACLRI </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.XPACLRI_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void XPACLRI()
         => AddInstruction(Arm64InstructionFactory.XPACLRI());
    /// <summary>
    /// Yield.
    /// </summary>
    /// <remarks><code>YIELD </code></remarks>
    [Arm64LinkInstructionId(Arm64InstructionId.YIELD_hi_hints), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void YIELD()
         => AddInstruction(Arm64InstructionFactory.YIELD());
}
